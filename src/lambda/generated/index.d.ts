// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activityLogItem: (where?: ActivityLogItemWhereInput) => Promise<boolean>;
  ballot: (where?: BallotWhereInput) => Promise<boolean>;
  bandaid: (where?: BandaidWhereInput) => Promise<boolean>;
  cloudinaryImage: (where?: CloudinaryImageWhereInput) => Promise<boolean>;
  condition: (where?: ConditionWhereInput) => Promise<boolean>;
  contactInfo: (where?: ContactInfoWhereInput) => Promise<boolean>;
  election: (where?: ElectionWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  membershipLogItem: (where?: MembershipLogItemWhereInput) => Promise<boolean>;
  preference: (where?: PreferenceWhereInput) => Promise<boolean>;
  rSVP: (where?: RSVPWhereInput) => Promise<boolean>;
  registration: (where?: RegistrationWhereInput) => Promise<boolean>;
  rigImage: (where?: RigImageWhereInput) => Promise<boolean>;
  runReport: (where?: RunReportWhereInput) => Promise<boolean>;
  trail: (where?: TrailWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userMeta: (where?: UserMetaWhereInput) => Promise<boolean>;
  vehicle: (where?: VehicleWhereInput) => Promise<boolean>;
  vote: (where?: VoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activityLogItem: (
    where: ActivityLogItemWhereUniqueInput
  ) => ActivityLogItemNullablePromise;
  activityLogItems: (args?: {
    where?: ActivityLogItemWhereInput;
    orderBy?: ActivityLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivityLogItem>;
  activityLogItemsConnection: (args?: {
    where?: ActivityLogItemWhereInput;
    orderBy?: ActivityLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityLogItemConnectionPromise;
  ballot: (where: BallotWhereUniqueInput) => BallotNullablePromise;
  ballots: (args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ballot>;
  ballotsConnection: (args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BallotConnectionPromise;
  bandaid: (where: BandaidWhereUniqueInput) => BandaidNullablePromise;
  bandaids: (args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bandaid>;
  bandaidsConnection: (args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BandaidConnectionPromise;
  cloudinaryImage: (
    where: CloudinaryImageWhereUniqueInput
  ) => CloudinaryImageNullablePromise;
  cloudinaryImages: (args?: {
    where?: CloudinaryImageWhereInput;
    orderBy?: CloudinaryImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CloudinaryImage>;
  cloudinaryImagesConnection: (args?: {
    where?: CloudinaryImageWhereInput;
    orderBy?: CloudinaryImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CloudinaryImageConnectionPromise;
  condition: (where: ConditionWhereUniqueInput) => ConditionNullablePromise;
  conditions: (args?: {
    where?: ConditionWhereInput;
    orderBy?: ConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Condition>;
  conditionsConnection: (args?: {
    where?: ConditionWhereInput;
    orderBy?: ConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConditionConnectionPromise;
  contactInfo: (
    where: ContactInfoWhereUniqueInput
  ) => ContactInfoNullablePromise;
  contactInfoes: (args?: {
    where?: ContactInfoWhereInput;
    orderBy?: ContactInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ContactInfo>;
  contactInfoesConnection: (args?: {
    where?: ContactInfoWhereInput;
    orderBy?: ContactInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactInfoConnectionPromise;
  election: (where: ElectionWhereUniqueInput) => ElectionNullablePromise;
  elections: (args?: {
    where?: ElectionWhereInput;
    orderBy?: ElectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Election>;
  electionsConnection: (args?: {
    where?: ElectionWhereInput;
    orderBy?: ElectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ElectionConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  membershipLogItem: (
    where: MembershipLogItemWhereUniqueInput
  ) => MembershipLogItemNullablePromise;
  membershipLogItems: (args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MembershipLogItem>;
  membershipLogItemsConnection: (args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MembershipLogItemConnectionPromise;
  preference: (where: PreferenceWhereUniqueInput) => PreferenceNullablePromise;
  preferences: (args?: {
    where?: PreferenceWhereInput;
    orderBy?: PreferenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Preference>;
  preferencesConnection: (args?: {
    where?: PreferenceWhereInput;
    orderBy?: PreferenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreferenceConnectionPromise;
  rSVP: (where: RSVPWhereUniqueInput) => RSVPNullablePromise;
  rSVPs: (args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RSVP>;
  rSVPsConnection: (args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RSVPConnectionPromise;
  registration: (
    where: RegistrationWhereUniqueInput
  ) => RegistrationNullablePromise;
  registrations: (args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Registration>;
  registrationsConnection: (args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegistrationConnectionPromise;
  rigImage: (where: RigImageWhereUniqueInput) => RigImageNullablePromise;
  rigImages: (args?: {
    where?: RigImageWhereInput;
    orderBy?: RigImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RigImage>;
  rigImagesConnection: (args?: {
    where?: RigImageWhereInput;
    orderBy?: RigImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RigImageConnectionPromise;
  runReport: (where: RunReportWhereUniqueInput) => RunReportNullablePromise;
  runReports: (args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RunReport>;
  runReportsConnection: (args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RunReportConnectionPromise;
  trail: (where: TrailWhereUniqueInput) => TrailNullablePromise;
  trails: (args?: {
    where?: TrailWhereInput;
    orderBy?: TrailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Trail>;
  trailsConnection: (args?: {
    where?: TrailWhereInput;
    orderBy?: TrailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrailConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userMeta: (where: UserMetaWhereUniqueInput) => UserMetaNullablePromise;
  userMetas: (args?: {
    where?: UserMetaWhereInput;
    orderBy?: UserMetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserMeta>;
  userMetasConnection: (args?: {
    where?: UserMetaWhereInput;
    orderBy?: UserMetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserMetaConnectionPromise;
  vehicle: (where: VehicleWhereUniqueInput) => VehicleNullablePromise;
  vehicles: (args?: {
    where?: VehicleWhereInput;
    orderBy?: VehicleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vehicle>;
  vehiclesConnection: (args?: {
    where?: VehicleWhereInput;
    orderBy?: VehicleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VehicleConnectionPromise;
  vote: (where: VoteWhereUniqueInput) => VoteNullablePromise;
  votes: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vote>;
  votesConnection: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivityLogItem: (
    data: ActivityLogItemCreateInput
  ) => ActivityLogItemPromise;
  updateActivityLogItem: (args: {
    data: ActivityLogItemUpdateInput;
    where: ActivityLogItemWhereUniqueInput;
  }) => ActivityLogItemPromise;
  updateManyActivityLogItems: (args: {
    data: ActivityLogItemUpdateManyMutationInput;
    where?: ActivityLogItemWhereInput;
  }) => BatchPayloadPromise;
  upsertActivityLogItem: (args: {
    where: ActivityLogItemWhereUniqueInput;
    create: ActivityLogItemCreateInput;
    update: ActivityLogItemUpdateInput;
  }) => ActivityLogItemPromise;
  deleteActivityLogItem: (
    where: ActivityLogItemWhereUniqueInput
  ) => ActivityLogItemPromise;
  deleteManyActivityLogItems: (
    where?: ActivityLogItemWhereInput
  ) => BatchPayloadPromise;
  createBallot: (data: BallotCreateInput) => BallotPromise;
  updateBallot: (args: {
    data: BallotUpdateInput;
    where: BallotWhereUniqueInput;
  }) => BallotPromise;
  updateManyBallots: (args: {
    data: BallotUpdateManyMutationInput;
    where?: BallotWhereInput;
  }) => BatchPayloadPromise;
  upsertBallot: (args: {
    where: BallotWhereUniqueInput;
    create: BallotCreateInput;
    update: BallotUpdateInput;
  }) => BallotPromise;
  deleteBallot: (where: BallotWhereUniqueInput) => BallotPromise;
  deleteManyBallots: (where?: BallotWhereInput) => BatchPayloadPromise;
  createBandaid: (data: BandaidCreateInput) => BandaidPromise;
  updateBandaid: (args: {
    data: BandaidUpdateInput;
    where: BandaidWhereUniqueInput;
  }) => BandaidPromise;
  updateManyBandaids: (args: {
    data: BandaidUpdateManyMutationInput;
    where?: BandaidWhereInput;
  }) => BatchPayloadPromise;
  upsertBandaid: (args: {
    where: BandaidWhereUniqueInput;
    create: BandaidCreateInput;
    update: BandaidUpdateInput;
  }) => BandaidPromise;
  deleteBandaid: (where: BandaidWhereUniqueInput) => BandaidPromise;
  deleteManyBandaids: (where?: BandaidWhereInput) => BatchPayloadPromise;
  createCloudinaryImage: (
    data: CloudinaryImageCreateInput
  ) => CloudinaryImagePromise;
  updateCloudinaryImage: (args: {
    data: CloudinaryImageUpdateInput;
    where: CloudinaryImageWhereUniqueInput;
  }) => CloudinaryImagePromise;
  updateManyCloudinaryImages: (args: {
    data: CloudinaryImageUpdateManyMutationInput;
    where?: CloudinaryImageWhereInput;
  }) => BatchPayloadPromise;
  upsertCloudinaryImage: (args: {
    where: CloudinaryImageWhereUniqueInput;
    create: CloudinaryImageCreateInput;
    update: CloudinaryImageUpdateInput;
  }) => CloudinaryImagePromise;
  deleteCloudinaryImage: (
    where: CloudinaryImageWhereUniqueInput
  ) => CloudinaryImagePromise;
  deleteManyCloudinaryImages: (
    where?: CloudinaryImageWhereInput
  ) => BatchPayloadPromise;
  createCondition: (data: ConditionCreateInput) => ConditionPromise;
  updateCondition: (args: {
    data: ConditionUpdateInput;
    where: ConditionWhereUniqueInput;
  }) => ConditionPromise;
  updateManyConditions: (args: {
    data: ConditionUpdateManyMutationInput;
    where?: ConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertCondition: (args: {
    where: ConditionWhereUniqueInput;
    create: ConditionCreateInput;
    update: ConditionUpdateInput;
  }) => ConditionPromise;
  deleteCondition: (where: ConditionWhereUniqueInput) => ConditionPromise;
  deleteManyConditions: (where?: ConditionWhereInput) => BatchPayloadPromise;
  createContactInfo: (data: ContactInfoCreateInput) => ContactInfoPromise;
  updateContactInfo: (args: {
    data: ContactInfoUpdateInput;
    where: ContactInfoWhereUniqueInput;
  }) => ContactInfoPromise;
  updateManyContactInfoes: (args: {
    data: ContactInfoUpdateManyMutationInput;
    where?: ContactInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertContactInfo: (args: {
    where: ContactInfoWhereUniqueInput;
    create: ContactInfoCreateInput;
    update: ContactInfoUpdateInput;
  }) => ContactInfoPromise;
  deleteContactInfo: (where: ContactInfoWhereUniqueInput) => ContactInfoPromise;
  deleteManyContactInfoes: (
    where?: ContactInfoWhereInput
  ) => BatchPayloadPromise;
  createElection: (data: ElectionCreateInput) => ElectionPromise;
  updateElection: (args: {
    data: ElectionUpdateInput;
    where: ElectionWhereUniqueInput;
  }) => ElectionPromise;
  updateManyElections: (args: {
    data: ElectionUpdateManyMutationInput;
    where?: ElectionWhereInput;
  }) => BatchPayloadPromise;
  upsertElection: (args: {
    where: ElectionWhereUniqueInput;
    create: ElectionCreateInput;
    update: ElectionUpdateInput;
  }) => ElectionPromise;
  deleteElection: (where: ElectionWhereUniqueInput) => ElectionPromise;
  deleteManyElections: (where?: ElectionWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createMembershipLogItem: (
    data: MembershipLogItemCreateInput
  ) => MembershipLogItemPromise;
  updateMembershipLogItem: (args: {
    data: MembershipLogItemUpdateInput;
    where: MembershipLogItemWhereUniqueInput;
  }) => MembershipLogItemPromise;
  updateManyMembershipLogItems: (args: {
    data: MembershipLogItemUpdateManyMutationInput;
    where?: MembershipLogItemWhereInput;
  }) => BatchPayloadPromise;
  upsertMembershipLogItem: (args: {
    where: MembershipLogItemWhereUniqueInput;
    create: MembershipLogItemCreateInput;
    update: MembershipLogItemUpdateInput;
  }) => MembershipLogItemPromise;
  deleteMembershipLogItem: (
    where: MembershipLogItemWhereUniqueInput
  ) => MembershipLogItemPromise;
  deleteManyMembershipLogItems: (
    where?: MembershipLogItemWhereInput
  ) => BatchPayloadPromise;
  createPreference: (data: PreferenceCreateInput) => PreferencePromise;
  updatePreference: (args: {
    data: PreferenceUpdateInput;
    where: PreferenceWhereUniqueInput;
  }) => PreferencePromise;
  updateManyPreferences: (args: {
    data: PreferenceUpdateManyMutationInput;
    where?: PreferenceWhereInput;
  }) => BatchPayloadPromise;
  upsertPreference: (args: {
    where: PreferenceWhereUniqueInput;
    create: PreferenceCreateInput;
    update: PreferenceUpdateInput;
  }) => PreferencePromise;
  deletePreference: (where: PreferenceWhereUniqueInput) => PreferencePromise;
  deleteManyPreferences: (where?: PreferenceWhereInput) => BatchPayloadPromise;
  createRSVP: (data: RSVPCreateInput) => RSVPPromise;
  updateRSVP: (args: {
    data: RSVPUpdateInput;
    where: RSVPWhereUniqueInput;
  }) => RSVPPromise;
  updateManyRSVPs: (args: {
    data: RSVPUpdateManyMutationInput;
    where?: RSVPWhereInput;
  }) => BatchPayloadPromise;
  upsertRSVP: (args: {
    where: RSVPWhereUniqueInput;
    create: RSVPCreateInput;
    update: RSVPUpdateInput;
  }) => RSVPPromise;
  deleteRSVP: (where: RSVPWhereUniqueInput) => RSVPPromise;
  deleteManyRSVPs: (where?: RSVPWhereInput) => BatchPayloadPromise;
  createRegistration: (data: RegistrationCreateInput) => RegistrationPromise;
  updateRegistration: (args: {
    data: RegistrationUpdateInput;
    where: RegistrationWhereUniqueInput;
  }) => RegistrationPromise;
  updateManyRegistrations: (args: {
    data: RegistrationUpdateManyMutationInput;
    where?: RegistrationWhereInput;
  }) => BatchPayloadPromise;
  upsertRegistration: (args: {
    where: RegistrationWhereUniqueInput;
    create: RegistrationCreateInput;
    update: RegistrationUpdateInput;
  }) => RegistrationPromise;
  deleteRegistration: (
    where: RegistrationWhereUniqueInput
  ) => RegistrationPromise;
  deleteManyRegistrations: (
    where?: RegistrationWhereInput
  ) => BatchPayloadPromise;
  createRigImage: (data: RigImageCreateInput) => RigImagePromise;
  updateRigImage: (args: {
    data: RigImageUpdateInput;
    where: RigImageWhereUniqueInput;
  }) => RigImagePromise;
  upsertRigImage: (args: {
    where: RigImageWhereUniqueInput;
    create: RigImageCreateInput;
    update: RigImageUpdateInput;
  }) => RigImagePromise;
  deleteRigImage: (where: RigImageWhereUniqueInput) => RigImagePromise;
  deleteManyRigImages: (where?: RigImageWhereInput) => BatchPayloadPromise;
  createRunReport: (data: RunReportCreateInput) => RunReportPromise;
  updateRunReport: (args: {
    data: RunReportUpdateInput;
    where: RunReportWhereUniqueInput;
  }) => RunReportPromise;
  updateManyRunReports: (args: {
    data: RunReportUpdateManyMutationInput;
    where?: RunReportWhereInput;
  }) => BatchPayloadPromise;
  upsertRunReport: (args: {
    where: RunReportWhereUniqueInput;
    create: RunReportCreateInput;
    update: RunReportUpdateInput;
  }) => RunReportPromise;
  deleteRunReport: (where: RunReportWhereUniqueInput) => RunReportPromise;
  deleteManyRunReports: (where?: RunReportWhereInput) => BatchPayloadPromise;
  createTrail: (data: TrailCreateInput) => TrailPromise;
  updateTrail: (args: {
    data: TrailUpdateInput;
    where: TrailWhereUniqueInput;
  }) => TrailPromise;
  updateManyTrails: (args: {
    data: TrailUpdateManyMutationInput;
    where?: TrailWhereInput;
  }) => BatchPayloadPromise;
  upsertTrail: (args: {
    where: TrailWhereUniqueInput;
    create: TrailCreateInput;
    update: TrailUpdateInput;
  }) => TrailPromise;
  deleteTrail: (where: TrailWhereUniqueInput) => TrailPromise;
  deleteManyTrails: (where?: TrailWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserMeta: (data: UserMetaCreateInput) => UserMetaPromise;
  updateUserMeta: (args: {
    data: UserMetaUpdateInput;
    where: UserMetaWhereUniqueInput;
  }) => UserMetaPromise;
  updateManyUserMetas: (args: {
    data: UserMetaUpdateManyMutationInput;
    where?: UserMetaWhereInput;
  }) => BatchPayloadPromise;
  upsertUserMeta: (args: {
    where: UserMetaWhereUniqueInput;
    create: UserMetaCreateInput;
    update: UserMetaUpdateInput;
  }) => UserMetaPromise;
  deleteUserMeta: (where: UserMetaWhereUniqueInput) => UserMetaPromise;
  deleteManyUserMetas: (where?: UserMetaWhereInput) => BatchPayloadPromise;
  createVehicle: (data: VehicleCreateInput) => VehiclePromise;
  updateVehicle: (args: {
    data: VehicleUpdateInput;
    where: VehicleWhereUniqueInput;
  }) => VehiclePromise;
  updateManyVehicles: (args: {
    data: VehicleUpdateManyMutationInput;
    where?: VehicleWhereInput;
  }) => BatchPayloadPromise;
  upsertVehicle: (args: {
    where: VehicleWhereUniqueInput;
    create: VehicleCreateInput;
    update: VehicleUpdateInput;
  }) => VehiclePromise;
  deleteVehicle: (where: VehicleWhereUniqueInput) => VehiclePromise;
  deleteManyVehicles: (where?: VehicleWhereInput) => BatchPayloadPromise;
  createVote: (data: VoteCreateInput) => VotePromise;
  updateVote: (args: {
    data: VoteUpdateInput;
    where: VoteWhereUniqueInput;
  }) => VotePromise;
  upsertVote: (args: {
    where: VoteWhereUniqueInput;
    create: VoteCreateInput;
    update: VoteUpdateInput;
  }) => VotePromise;
  deleteVote: (where: VoteWhereUniqueInput) => VotePromise;
  deleteManyVotes: (where?: VoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activityLogItem: (
    where?: ActivityLogItemSubscriptionWhereInput
  ) => ActivityLogItemSubscriptionPayloadSubscription;
  ballot: (
    where?: BallotSubscriptionWhereInput
  ) => BallotSubscriptionPayloadSubscription;
  bandaid: (
    where?: BandaidSubscriptionWhereInput
  ) => BandaidSubscriptionPayloadSubscription;
  cloudinaryImage: (
    where?: CloudinaryImageSubscriptionWhereInput
  ) => CloudinaryImageSubscriptionPayloadSubscription;
  condition: (
    where?: ConditionSubscriptionWhereInput
  ) => ConditionSubscriptionPayloadSubscription;
  contactInfo: (
    where?: ContactInfoSubscriptionWhereInput
  ) => ContactInfoSubscriptionPayloadSubscription;
  election: (
    where?: ElectionSubscriptionWhereInput
  ) => ElectionSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  membershipLogItem: (
    where?: MembershipLogItemSubscriptionWhereInput
  ) => MembershipLogItemSubscriptionPayloadSubscription;
  preference: (
    where?: PreferenceSubscriptionWhereInput
  ) => PreferenceSubscriptionPayloadSubscription;
  rSVP: (
    where?: RSVPSubscriptionWhereInput
  ) => RSVPSubscriptionPayloadSubscription;
  registration: (
    where?: RegistrationSubscriptionWhereInput
  ) => RegistrationSubscriptionPayloadSubscription;
  rigImage: (
    where?: RigImageSubscriptionWhereInput
  ) => RigImageSubscriptionPayloadSubscription;
  runReport: (
    where?: RunReportSubscriptionWhereInput
  ) => RunReportSubscriptionPayloadSubscription;
  trail: (
    where?: TrailSubscriptionWhereInput
  ) => TrailSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userMeta: (
    where?: UserMetaSubscriptionWhereInput
  ) => UserMetaSubscriptionPayloadSubscription;
  vehicle: (
    where?: VehicleSubscriptionWhereInput
  ) => VehicleSubscriptionPayloadSubscription;
  vote: (
    where?: VoteSubscriptionWhereInput
  ) => VoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ActivityMessageCode =
  | "EVENT_ATTENDED"
  | "RUN_LEAD"
  | "EVENT_REVIEW_SUBMITTED"
  | "RUN_REPORT_SUBMITTED"
  | "GALLERY_PHOTO_SUBMITTED"
  | "GALLERY_PHOTOS_SUBMITTED"
  | "PROFILE_PHOTO_SUBMITTED"
  | "RIGBOOK_PHOTO_SUBMITTED"
  | "JOINED";

export type Gender = "MALE" | "FEMALE" | "OTHER" | "UNDISCLOSED";

export type OutfitLevel = "MODIFIED" | "STOCK";

export type Title = "WEBMASTER" | "CHARTER_MEMBER" | "HISTORIAN";

export type Role = "ADMIN" | "OFFICER" | "RUN_MASTER" | "RUN_LEADER" | "USER";

export type AccountStatus =
  | "ACTIVE"
  | "PAST_DUE"
  | "DELINQUENT"
  | "REMOVED"
  | "RESIGNED"
  | "INACTIVE"
  | "LIMITED"
  | "LOCKED";

export type AccountType = "FULL" | "ASSOCIATE" | "EMERITUS" | "GUEST";

export type Office = "PRESIDENT" | "VICE_PRESIDENT" | "SECRETARY" | "TREASURER";

export type MembershipMessageCode =
  | "ACCOUNT_CREATED"
  | "ACCOUNT_UNLOCKED"
  | "ACCOUNT_CHANGED"
  | "ACCOUNT_REJECTED"
  | "DUES_PAID"
  | "OFFICE_ADDED"
  | "OFFICE_REMOVED"
  | "TITLE_ADDED"
  | "TITLE_REMOVED"
  | "MEMBERSHIP_ELIGIBLE"
  | "MEMBERSHIP_GRANTED"
  | "GUEST_RESTRICTED";

export type EventType =
  | "RUN"
  | "COLLECTION"
  | "FUNDRAISING"
  | "MEETING"
  | "CLINIC"
  | "SOCIAL";

export type RSVPStatus = "NONE" | "CANT_GO" | "GOING" | "MAYBE";

export type TrailDifficulty =
  | "UNKNOWN"
  | "BEGINNER"
  | "INTERMEDIATE"
  | "ADVANCED";

export type TrailCondition =
  | "CLEAR"
  | "MINOR_ISSUES"
  | "MAJOR_ISSUES"
  | "CLOSED";

export type BallotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "joined_ASC"
  | "joined_DESC"
  | "lastLogin_ASC"
  | "lastLogin_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "birthdate_ASC"
  | "birthdate_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "isCharterMember_ASC"
  | "isCharterMember_DESC"
  | "title_ASC"
  | "title_DESC"
  | "role_ASC"
  | "role_DESC"
  | "accountStatus_ASC"
  | "accountStatus_DESC"
  | "accountType_ASC"
  | "accountType_DESC"
  | "office_ASC"
  | "office_DESC"
  | "comfortLevel_ASC"
  | "comfortLevel_DESC";

export type VoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityLogItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "time_ASC"
  | "time_DESC"
  | "message_ASC"
  | "message_DESC"
  | "messageCode_ASC"
  | "messageCode_DESC"
  | "link_ASC"
  | "link_DESC";

export type MembershipLogItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "time_ASC"
  | "time_DESC"
  | "message_ASC"
  | "message_DESC"
  | "messageCode_ASC"
  | "messageCode_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "address_ASC"
  | "address_DESC"
  | "trailDifficulty_ASC"
  | "trailDifficulty_DESC"
  | "trailNotes_ASC"
  | "trailNotes_DESC"
  | "rallyAddress_ASC"
  | "rallyAddress_DESC"
  | "rallyTime_ASC"
  | "rallyTime_DESC"
  | "membersOnly_ASC"
  | "membersOnly_DESC";

export type RSVPOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC";

export type RunReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "reportFiled_ASC"
  | "reportFiled_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "weather_ASC"
  | "weather_DESC"
  | "difficulty_ASC"
  | "difficulty_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "favorite_ASC"
  | "favorite_DESC";

export type BandaidOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type TrailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "trailheadCoords_ASC"
  | "trailheadCoords_DESC"
  | "address_ASC"
  | "address_DESC"
  | "avgDifficulty_ASC"
  | "avgDifficulty_DESC"
  | "avgRatings_ASC"
  | "avgRatings_DESC"
  | "currentConditions_ASC"
  | "currentConditions_DESC"
  | "conditionsLastReported_ASC"
  | "conditionsLastReported_DESC"
  | "favoriteCount_ASC"
  | "favoriteCount_DESC";

export type CloudinaryImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "publicId_ASC"
  | "publicId_DESC"
  | "url_ASC"
  | "url_DESC"
  | "smallUrl_ASC"
  | "smallUrl_DESC";

export type ConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type ContactInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type ElectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "electionName_ASC"
  | "electionName_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC";

export type PreferenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "emergencyContactName_ASC"
  | "emergencyContactName_DESC"
  | "emergencyContactPhone_ASC"
  | "emergencyContactPhone_DESC"
  | "photoPermissions_ASC"
  | "photoPermissions_DESC"
  | "showPhoneNumber_ASC"
  | "showPhoneNumber_DESC";

export type RegistrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "source_ASC"
  | "source_DESC"
  | "token_ASC"
  | "token_DESC"
  | "tokenExpiry_ASC"
  | "tokenExpiry_DESC";

export type RigImageOrderByInput = "id_ASC" | "id_DESC";

export type UserMetaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "firstLoginComplete_ASC"
  | "firstLoginComplete_DESC"
  | "accountSetupComplete_ASC"
  | "accountSetupComplete_DESC"
  | "oldSitemigrationComplete_ASC"
  | "oldSitemigrationComplete_DESC";

export type VehicleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "make_ASC"
  | "make_DESC"
  | "model_ASC"
  | "model_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trim_ASC"
  | "trim_DESC"
  | "outfitLevel_ASC"
  | "outfitLevel_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivityLogItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BallotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  candidates_every?: Maybe<UserWhereInput>;
  candidates_some?: Maybe<UserWhereInput>;
  candidates_none?: Maybe<UserWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  AND?: Maybe<BallotWhereInput[] | BallotWhereInput>;
  OR?: Maybe<BallotWhereInput[] | BallotWhereInput>;
  NOT?: Maybe<BallotWhereInput[] | BallotWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  joined?: Maybe<DateTimeInput>;
  joined_not?: Maybe<DateTimeInput>;
  joined_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joined_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joined_lt?: Maybe<DateTimeInput>;
  joined_lte?: Maybe<DateTimeInput>;
  joined_gt?: Maybe<DateTimeInput>;
  joined_gte?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  lastLogin_not?: Maybe<DateTimeInput>;
  lastLogin_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastLogin_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastLogin_lt?: Maybe<DateTimeInput>;
  lastLogin_lte?: Maybe<DateTimeInput>;
  lastLogin_gt?: Maybe<DateTimeInput>;
  lastLogin_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  birthdate?: Maybe<DateTimeInput>;
  birthdate_not?: Maybe<DateTimeInput>;
  birthdate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_lt?: Maybe<DateTimeInput>;
  birthdate_lte?: Maybe<DateTimeInput>;
  birthdate_gt?: Maybe<DateTimeInput>;
  birthdate_gte?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoWhereInput>;
  preferences?: Maybe<PreferenceWhereInput>;
  userMeta?: Maybe<UserMetaWhereInput>;
  avatar?: Maybe<CloudinaryImageWhereInput>;
  isCharterMember?: Maybe<Boolean>;
  isCharterMember_not?: Maybe<Boolean>;
  rig?: Maybe<RigImageWhereInput>;
  vehicle?: Maybe<VehicleWhereInput>;
  title?: Maybe<Title>;
  title_not?: Maybe<Title>;
  title_in?: Maybe<Title[] | Title>;
  title_not_in?: Maybe<Title[] | Title>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountStatus_not?: Maybe<AccountStatus>;
  accountStatus_in?: Maybe<AccountStatus[] | AccountStatus>;
  accountStatus_not_in?: Maybe<AccountStatus[] | AccountStatus>;
  accountType?: Maybe<AccountType>;
  accountType_not?: Maybe<AccountType>;
  accountType_in?: Maybe<AccountType[] | AccountType>;
  accountType_not_in?: Maybe<AccountType[] | AccountType>;
  office?: Maybe<Office>;
  office_not?: Maybe<Office>;
  office_in?: Maybe<Office[] | Office>;
  office_not_in?: Maybe<Office[] | Office>;
  candidateFor_every?: Maybe<BallotWhereInput>;
  candidateFor_some?: Maybe<BallotWhereInput>;
  candidateFor_none?: Maybe<BallotWhereInput>;
  votesReceived_every?: Maybe<VoteWhereInput>;
  votesReceived_some?: Maybe<VoteWhereInput>;
  votesReceived_none?: Maybe<VoteWhereInput>;
  votedFor_every?: Maybe<VoteWhereInput>;
  votedFor_some?: Maybe<VoteWhereInput>;
  votedFor_none?: Maybe<VoteWhereInput>;
  comfortLevel?: Maybe<String>;
  comfortLevel_not?: Maybe<String>;
  comfortLevel_in?: Maybe<String[] | String>;
  comfortLevel_not_in?: Maybe<String[] | String>;
  comfortLevel_lt?: Maybe<String>;
  comfortLevel_lte?: Maybe<String>;
  comfortLevel_gt?: Maybe<String>;
  comfortLevel_gte?: Maybe<String>;
  comfortLevel_contains?: Maybe<String>;
  comfortLevel_not_contains?: Maybe<String>;
  comfortLevel_starts_with?: Maybe<String>;
  comfortLevel_not_starts_with?: Maybe<String>;
  comfortLevel_ends_with?: Maybe<String>;
  comfortLevel_not_ends_with?: Maybe<String>;
  activityLog_every?: Maybe<ActivityLogItemWhereInput>;
  activityLog_some?: Maybe<ActivityLogItemWhereInput>;
  activityLog_none?: Maybe<ActivityLogItemWhereInput>;
  membershipLog_every?: Maybe<MembershipLogItemWhereInput>;
  membershipLog_some?: Maybe<MembershipLogItemWhereInput>;
  membershipLog_none?: Maybe<MembershipLogItemWhereInput>;
  membershipLogContributions_every?: Maybe<MembershipLogItemWhereInput>;
  membershipLogContributions_some?: Maybe<MembershipLogItemWhereInput>;
  membershipLogContributions_none?: Maybe<MembershipLogItemWhereInput>;
  eventsCreated_every?: Maybe<EventWhereInput>;
  eventsCreated_some?: Maybe<EventWhereInput>;
  eventsCreated_none?: Maybe<EventWhereInput>;
  eventsRSVPd_every?: Maybe<RSVPWhereInput>;
  eventsRSVPd_some?: Maybe<RSVPWhereInput>;
  eventsRSVPd_none?: Maybe<RSVPWhereInput>;
  eventsHosted_every?: Maybe<EventWhereInput>;
  eventsHosted_some?: Maybe<EventWhereInput>;
  eventsHosted_none?: Maybe<EventWhereInput>;
  trailsVisited_every?: Maybe<TrailWhereInput>;
  trailsVisited_some?: Maybe<TrailWhereInput>;
  trailsVisited_none?: Maybe<TrailWhereInput>;
  bandaids_every?: Maybe<BandaidWhereInput>;
  bandaids_some?: Maybe<BandaidWhereInput>;
  bandaids_none?: Maybe<BandaidWhereInput>;
  runReportsLogged_every?: Maybe<RunReportWhereInput>;
  runReportsLogged_some?: Maybe<RunReportWhereInput>;
  runReportsLogged_none?: Maybe<RunReportWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ContactInfoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactInfoWhereInput[] | ContactInfoWhereInput>;
  OR?: Maybe<ContactInfoWhereInput[] | ContactInfoWhereInput>;
  NOT?: Maybe<ContactInfoWhereInput[] | ContactInfoWhereInput>;
}

export interface PreferenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  emergencyContactName?: Maybe<String>;
  emergencyContactName_not?: Maybe<String>;
  emergencyContactName_in?: Maybe<String[] | String>;
  emergencyContactName_not_in?: Maybe<String[] | String>;
  emergencyContactName_lt?: Maybe<String>;
  emergencyContactName_lte?: Maybe<String>;
  emergencyContactName_gt?: Maybe<String>;
  emergencyContactName_gte?: Maybe<String>;
  emergencyContactName_contains?: Maybe<String>;
  emergencyContactName_not_contains?: Maybe<String>;
  emergencyContactName_starts_with?: Maybe<String>;
  emergencyContactName_not_starts_with?: Maybe<String>;
  emergencyContactName_ends_with?: Maybe<String>;
  emergencyContactName_not_ends_with?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  emergencyContactPhone_not?: Maybe<String>;
  emergencyContactPhone_in?: Maybe<String[] | String>;
  emergencyContactPhone_not_in?: Maybe<String[] | String>;
  emergencyContactPhone_lt?: Maybe<String>;
  emergencyContactPhone_lte?: Maybe<String>;
  emergencyContactPhone_gt?: Maybe<String>;
  emergencyContactPhone_gte?: Maybe<String>;
  emergencyContactPhone_contains?: Maybe<String>;
  emergencyContactPhone_not_contains?: Maybe<String>;
  emergencyContactPhone_starts_with?: Maybe<String>;
  emergencyContactPhone_not_starts_with?: Maybe<String>;
  emergencyContactPhone_ends_with?: Maybe<String>;
  emergencyContactPhone_not_ends_with?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  photoPermissions_not?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
  showPhoneNumber_not?: Maybe<Boolean>;
  AND?: Maybe<PreferenceWhereInput[] | PreferenceWhereInput>;
  OR?: Maybe<PreferenceWhereInput[] | PreferenceWhereInput>;
  NOT?: Maybe<PreferenceWhereInput[] | PreferenceWhereInput>;
}

export interface UserMetaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  firstLoginComplete_not?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  accountSetupComplete_not?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
  oldSitemigrationComplete_not?: Maybe<Boolean>;
  AND?: Maybe<UserMetaWhereInput[] | UserMetaWhereInput>;
  OR?: Maybe<UserMetaWhereInput[] | UserMetaWhereInput>;
  NOT?: Maybe<UserMetaWhereInput[] | UserMetaWhereInput>;
}

export interface CloudinaryImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  publicId?: Maybe<String>;
  publicId_not?: Maybe<String>;
  publicId_in?: Maybe<String[] | String>;
  publicId_not_in?: Maybe<String[] | String>;
  publicId_lt?: Maybe<String>;
  publicId_lte?: Maybe<String>;
  publicId_gt?: Maybe<String>;
  publicId_gte?: Maybe<String>;
  publicId_contains?: Maybe<String>;
  publicId_not_contains?: Maybe<String>;
  publicId_starts_with?: Maybe<String>;
  publicId_not_starts_with?: Maybe<String>;
  publicId_ends_with?: Maybe<String>;
  publicId_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  smallUrl?: Maybe<String>;
  smallUrl_not?: Maybe<String>;
  smallUrl_in?: Maybe<String[] | String>;
  smallUrl_not_in?: Maybe<String[] | String>;
  smallUrl_lt?: Maybe<String>;
  smallUrl_lte?: Maybe<String>;
  smallUrl_gt?: Maybe<String>;
  smallUrl_gte?: Maybe<String>;
  smallUrl_contains?: Maybe<String>;
  smallUrl_not_contains?: Maybe<String>;
  smallUrl_starts_with?: Maybe<String>;
  smallUrl_not_starts_with?: Maybe<String>;
  smallUrl_ends_with?: Maybe<String>;
  smallUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<CloudinaryImageWhereInput[] | CloudinaryImageWhereInput>;
  OR?: Maybe<CloudinaryImageWhereInput[] | CloudinaryImageWhereInput>;
  NOT?: Maybe<CloudinaryImageWhereInput[] | CloudinaryImageWhereInput>;
}

export interface RigImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<CloudinaryImageWhereInput>;
  AND?: Maybe<RigImageWhereInput[] | RigImageWhereInput>;
  OR?: Maybe<RigImageWhereInput[] | RigImageWhereInput>;
  NOT?: Maybe<RigImageWhereInput[] | RigImageWhereInput>;
}

export interface VehicleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  make?: Maybe<String>;
  make_not?: Maybe<String>;
  make_in?: Maybe<String[] | String>;
  make_not_in?: Maybe<String[] | String>;
  make_lt?: Maybe<String>;
  make_lte?: Maybe<String>;
  make_gt?: Maybe<String>;
  make_gte?: Maybe<String>;
  make_contains?: Maybe<String>;
  make_not_contains?: Maybe<String>;
  make_starts_with?: Maybe<String>;
  make_not_starts_with?: Maybe<String>;
  make_ends_with?: Maybe<String>;
  make_not_ends_with?: Maybe<String>;
  model?: Maybe<String>;
  model_not?: Maybe<String>;
  model_in?: Maybe<String[] | String>;
  model_not_in?: Maybe<String[] | String>;
  model_lt?: Maybe<String>;
  model_lte?: Maybe<String>;
  model_gt?: Maybe<String>;
  model_gte?: Maybe<String>;
  model_contains?: Maybe<String>;
  model_not_contains?: Maybe<String>;
  model_starts_with?: Maybe<String>;
  model_not_starts_with?: Maybe<String>;
  model_ends_with?: Maybe<String>;
  model_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  trim?: Maybe<String>;
  trim_not?: Maybe<String>;
  trim_in?: Maybe<String[] | String>;
  trim_not_in?: Maybe<String[] | String>;
  trim_lt?: Maybe<String>;
  trim_lte?: Maybe<String>;
  trim_gt?: Maybe<String>;
  trim_gte?: Maybe<String>;
  trim_contains?: Maybe<String>;
  trim_not_contains?: Maybe<String>;
  trim_starts_with?: Maybe<String>;
  trim_not_starts_with?: Maybe<String>;
  trim_ends_with?: Maybe<String>;
  trim_not_ends_with?: Maybe<String>;
  image?: Maybe<CloudinaryImageWhereInput>;
  outfitLevel?: Maybe<OutfitLevel>;
  outfitLevel_not?: Maybe<OutfitLevel>;
  outfitLevel_in?: Maybe<OutfitLevel[] | OutfitLevel>;
  outfitLevel_not_in?: Maybe<OutfitLevel[] | OutfitLevel>;
  AND?: Maybe<VehicleWhereInput[] | VehicleWhereInput>;
  OR?: Maybe<VehicleWhereInput[] | VehicleWhereInput>;
  NOT?: Maybe<VehicleWhereInput[] | VehicleWhereInput>;
}

export interface VoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  ballot?: Maybe<BallotWhereInput>;
  candidate?: Maybe<UserWhereInput>;
  voter?: Maybe<UserWhereInput>;
  AND?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  OR?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  NOT?: Maybe<VoteWhereInput[] | VoteWhereInput>;
}

export interface ActivityLogItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  messageCode_not?: Maybe<ActivityMessageCode>;
  messageCode_in?: Maybe<ActivityMessageCode[] | ActivityMessageCode>;
  messageCode_not_in?: Maybe<ActivityMessageCode[] | ActivityMessageCode>;
  user?: Maybe<UserWhereInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  AND?: Maybe<ActivityLogItemWhereInput[] | ActivityLogItemWhereInput>;
  OR?: Maybe<ActivityLogItemWhereInput[] | ActivityLogItemWhereInput>;
  NOT?: Maybe<ActivityLogItemWhereInput[] | ActivityLogItemWhereInput>;
}

export interface MembershipLogItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
  messageCode_not?: Maybe<MembershipMessageCode>;
  messageCode_in?: Maybe<MembershipMessageCode[] | MembershipMessageCode>;
  messageCode_not_in?: Maybe<MembershipMessageCode[] | MembershipMessageCode>;
  user?: Maybe<UserWhereInput>;
  logger?: Maybe<UserWhereInput>;
  AND?: Maybe<MembershipLogItemWhereInput[] | MembershipLogItemWhereInput>;
  OR?: Maybe<MembershipLogItemWhereInput[] | MembershipLogItemWhereInput>;
  NOT?: Maybe<MembershipLogItemWhereInput[] | MembershipLogItemWhereInput>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<EventType>;
  type_not?: Maybe<EventType>;
  type_in?: Maybe<EventType[] | EventType>;
  type_not_in?: Maybe<EventType[] | EventType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  creator?: Maybe<UserWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  host?: Maybe<UserWhereInput>;
  rsvps_every?: Maybe<RSVPWhereInput>;
  rsvps_some?: Maybe<RSVPWhereInput>;
  rsvps_none?: Maybe<RSVPWhereInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailDifficulty_not?: Maybe<TrailDifficulty>;
  trailDifficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  trailDifficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  trailNotes?: Maybe<String>;
  trailNotes_not?: Maybe<String>;
  trailNotes_in?: Maybe<String[] | String>;
  trailNotes_not_in?: Maybe<String[] | String>;
  trailNotes_lt?: Maybe<String>;
  trailNotes_lte?: Maybe<String>;
  trailNotes_gt?: Maybe<String>;
  trailNotes_gte?: Maybe<String>;
  trailNotes_contains?: Maybe<String>;
  trailNotes_not_contains?: Maybe<String>;
  trailNotes_starts_with?: Maybe<String>;
  trailNotes_not_starts_with?: Maybe<String>;
  trailNotes_ends_with?: Maybe<String>;
  trailNotes_not_ends_with?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyAddress_not?: Maybe<String>;
  rallyAddress_in?: Maybe<String[] | String>;
  rallyAddress_not_in?: Maybe<String[] | String>;
  rallyAddress_lt?: Maybe<String>;
  rallyAddress_lte?: Maybe<String>;
  rallyAddress_gt?: Maybe<String>;
  rallyAddress_gte?: Maybe<String>;
  rallyAddress_contains?: Maybe<String>;
  rallyAddress_not_contains?: Maybe<String>;
  rallyAddress_starts_with?: Maybe<String>;
  rallyAddress_not_starts_with?: Maybe<String>;
  rallyAddress_ends_with?: Maybe<String>;
  rallyAddress_not_ends_with?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  rallyTime_not?: Maybe<DateTimeInput>;
  rallyTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  rallyTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  rallyTime_lt?: Maybe<DateTimeInput>;
  rallyTime_lte?: Maybe<DateTimeInput>;
  rallyTime_gt?: Maybe<DateTimeInput>;
  rallyTime_gte?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailWhereInput>;
  bandaids_every?: Maybe<BandaidWhereInput>;
  bandaids_some?: Maybe<BandaidWhereInput>;
  bandaids_none?: Maybe<BandaidWhereInput>;
  runReports_every?: Maybe<RunReportWhereInput>;
  runReports_some?: Maybe<RunReportWhereInput>;
  runReports_none?: Maybe<RunReportWhereInput>;
  membersOnly?: Maybe<Boolean>;
  membersOnly_not?: Maybe<Boolean>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface RSVPWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  member?: Maybe<UserWhereInput>;
  event?: Maybe<EventWhereInput>;
  status?: Maybe<RSVPStatus>;
  status_not?: Maybe<RSVPStatus>;
  status_in?: Maybe<RSVPStatus[] | RSVPStatus>;
  status_not_in?: Maybe<RSVPStatus[] | RSVPStatus>;
  AND?: Maybe<RSVPWhereInput[] | RSVPWhereInput>;
  OR?: Maybe<RSVPWhereInput[] | RSVPWhereInput>;
  NOT?: Maybe<RSVPWhereInput[] | RSVPWhereInput>;
}

export interface TrailWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageWhereInput>;
  trailheadCoords?: Maybe<String>;
  trailheadCoords_not?: Maybe<String>;
  trailheadCoords_in?: Maybe<String[] | String>;
  trailheadCoords_not_in?: Maybe<String[] | String>;
  trailheadCoords_lt?: Maybe<String>;
  trailheadCoords_lte?: Maybe<String>;
  trailheadCoords_gt?: Maybe<String>;
  trailheadCoords_gte?: Maybe<String>;
  trailheadCoords_contains?: Maybe<String>;
  trailheadCoords_not_contains?: Maybe<String>;
  trailheadCoords_starts_with?: Maybe<String>;
  trailheadCoords_not_starts_with?: Maybe<String>;
  trailheadCoords_ends_with?: Maybe<String>;
  trailheadCoords_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgDifficulty_not?: Maybe<TrailDifficulty>;
  avgDifficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  avgDifficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  avgRatings_not?: Maybe<Float>;
  avgRatings_in?: Maybe<Float[] | Float>;
  avgRatings_not_in?: Maybe<Float[] | Float>;
  avgRatings_lt?: Maybe<Float>;
  avgRatings_lte?: Maybe<Float>;
  avgRatings_gt?: Maybe<Float>;
  avgRatings_gte?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  currentConditions_not?: Maybe<String>;
  currentConditions_in?: Maybe<String[] | String>;
  currentConditions_not_in?: Maybe<String[] | String>;
  currentConditions_lt?: Maybe<String>;
  currentConditions_lte?: Maybe<String>;
  currentConditions_gt?: Maybe<String>;
  currentConditions_gte?: Maybe<String>;
  currentConditions_contains?: Maybe<String>;
  currentConditions_not_contains?: Maybe<String>;
  currentConditions_starts_with?: Maybe<String>;
  currentConditions_not_starts_with?: Maybe<String>;
  currentConditions_ends_with?: Maybe<String>;
  currentConditions_not_ends_with?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  conditionsLastReported_not?: Maybe<DateTimeInput>;
  conditionsLastReported_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  conditionsLastReported_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  conditionsLastReported_lt?: Maybe<DateTimeInput>;
  conditionsLastReported_lte?: Maybe<DateTimeInput>;
  conditionsLastReported_gt?: Maybe<DateTimeInput>;
  conditionsLastReported_gte?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  favoriteCount_not?: Maybe<Int>;
  favoriteCount_in?: Maybe<Int[] | Int>;
  favoriteCount_not_in?: Maybe<Int[] | Int>;
  favoriteCount_lt?: Maybe<Int>;
  favoriteCount_lte?: Maybe<Int>;
  favoriteCount_gt?: Maybe<Int>;
  favoriteCount_gte?: Maybe<Int>;
  pastEvents_every?: Maybe<EventWhereInput>;
  pastEvents_some?: Maybe<EventWhereInput>;
  pastEvents_none?: Maybe<EventWhereInput>;
  visitors_every?: Maybe<UserWhereInput>;
  visitors_some?: Maybe<UserWhereInput>;
  visitors_none?: Maybe<UserWhereInput>;
  runReports_every?: Maybe<RunReportWhereInput>;
  runReports_some?: Maybe<RunReportWhereInput>;
  runReports_none?: Maybe<RunReportWhereInput>;
  AND?: Maybe<TrailWhereInput[] | TrailWhereInput>;
  OR?: Maybe<TrailWhereInput[] | TrailWhereInput>;
  NOT?: Maybe<TrailWhereInput[] | TrailWhereInput>;
}

export interface RunReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reportFiled_not?: Maybe<DateTimeInput>;
  reportFiled_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportFiled_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportFiled_lt?: Maybe<DateTimeInput>;
  reportFiled_lte?: Maybe<DateTimeInput>;
  reportFiled_gt?: Maybe<DateTimeInput>;
  reportFiled_gte?: Maybe<DateTimeInput>;
  reporter?: Maybe<UserWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  trail?: Maybe<TrailWhereInput>;
  event?: Maybe<EventWhereInput>;
  weather?: Maybe<String>;
  weather_not?: Maybe<String>;
  weather_in?: Maybe<String[] | String>;
  weather_not_in?: Maybe<String[] | String>;
  weather_lt?: Maybe<String>;
  weather_lte?: Maybe<String>;
  weather_gt?: Maybe<String>;
  weather_gte?: Maybe<String>;
  weather_contains?: Maybe<String>;
  weather_not_contains?: Maybe<String>;
  weather_starts_with?: Maybe<String>;
  weather_not_starts_with?: Maybe<String>;
  weather_ends_with?: Maybe<String>;
  weather_not_ends_with?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  difficulty_not?: Maybe<TrailDifficulty>;
  difficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  difficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  condition?: Maybe<ConditionWhereInput>;
  favorite?: Maybe<Boolean>;
  favorite_not?: Maybe<Boolean>;
  AND?: Maybe<RunReportWhereInput[] | RunReportWhereInput>;
  OR?: Maybe<RunReportWhereInput[] | RunReportWhereInput>;
  NOT?: Maybe<RunReportWhereInput[] | RunReportWhereInput>;
}

export interface ConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  report?: Maybe<RunReportWhereInput>;
  status?: Maybe<TrailCondition>;
  status_not?: Maybe<TrailCondition>;
  status_in?: Maybe<TrailCondition[] | TrailCondition>;
  status_not_in?: Maybe<TrailCondition[] | TrailCondition>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<ConditionWhereInput[] | ConditionWhereInput>;
  OR?: Maybe<ConditionWhereInput[] | ConditionWhereInput>;
  NOT?: Maybe<ConditionWhereInput[] | ConditionWhereInput>;
}

export interface BandaidWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  event?: Maybe<EventWhereInput>;
  memberInvolved?: Maybe<UserWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BandaidWhereInput[] | BandaidWhereInput>;
  OR?: Maybe<BandaidWhereInput[] | BandaidWhereInput>;
  NOT?: Maybe<BandaidWhereInput[] | BandaidWhereInput>;
}

export type BallotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BandaidWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CloudinaryImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ContactInfoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ElectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ElectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  electionName?: Maybe<String>;
  electionName_not?: Maybe<String>;
  electionName_in?: Maybe<String[] | String>;
  electionName_not_in?: Maybe<String[] | String>;
  electionName_lt?: Maybe<String>;
  electionName_lte?: Maybe<String>;
  electionName_gt?: Maybe<String>;
  electionName_gte?: Maybe<String>;
  electionName_contains?: Maybe<String>;
  electionName_not_contains?: Maybe<String>;
  electionName_starts_with?: Maybe<String>;
  electionName_not_starts_with?: Maybe<String>;
  electionName_ends_with?: Maybe<String>;
  electionName_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  races_every?: Maybe<BallotWhereInput>;
  races_some?: Maybe<BallotWhereInput>;
  races_none?: Maybe<BallotWhereInput>;
  AND?: Maybe<ElectionWhereInput[] | ElectionWhereInput>;
  OR?: Maybe<ElectionWhereInput[] | ElectionWhereInput>;
  NOT?: Maybe<ElectionWhereInput[] | ElectionWhereInput>;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MembershipLogItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PreferenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RSVPWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RegistrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  token?: Maybe<String>;
}>;

export interface RegistrationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  tokenExpiry?: Maybe<Float>;
  tokenExpiry_not?: Maybe<Float>;
  tokenExpiry_in?: Maybe<Float[] | Float>;
  tokenExpiry_not_in?: Maybe<Float[] | Float>;
  tokenExpiry_lt?: Maybe<Float>;
  tokenExpiry_lte?: Maybe<Float>;
  tokenExpiry_gt?: Maybe<Float>;
  tokenExpiry_gte?: Maybe<Float>;
  AND?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
  OR?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
  NOT?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
}

export type RigImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RunReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TrailWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  office?: Maybe<Office>;
}>;

export type UserMetaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type VehicleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type VoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ActivityLogItemCreateInput {
  id?: Maybe<ID_Input>;
  time: DateTimeInput;
  message: String;
  messageCode: ActivityMessageCode;
  user: UserCreateOneWithoutActivityLogInput;
  link?: Maybe<String>;
}

export interface UserCreateOneWithoutActivityLogInput {
  create?: Maybe<UserCreateWithoutActivityLogInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutActivityLogInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface ContactInfoCreateOneWithoutUserInput {
  create?: Maybe<ContactInfoCreateWithoutUserInput>;
  connect?: Maybe<ContactInfoWhereUniqueInput>;
}

export interface ContactInfoCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  phone: String;
}

export interface PreferenceCreateOneWithoutUserInput {
  create?: Maybe<PreferenceCreateWithoutUserInput>;
  connect?: Maybe<PreferenceWhereUniqueInput>;
}

export interface PreferenceCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  emergencyContactName?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
}

export interface UserMetaCreateOneWithoutUserInput {
  create?: Maybe<UserMetaCreateWithoutUserInput>;
  connect?: Maybe<UserMetaWhereUniqueInput>;
}

export interface UserMetaCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  emailVerified?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
}

export interface CloudinaryImageCreateOneInput {
  create?: Maybe<CloudinaryImageCreateInput>;
  connect?: Maybe<CloudinaryImageWhereUniqueInput>;
}

export interface CloudinaryImageCreateInput {
  id?: Maybe<ID_Input>;
  publicId: String;
  url?: Maybe<String>;
  smallUrl?: Maybe<String>;
}

export interface RigImageCreateOneInput {
  create?: Maybe<RigImageCreateInput>;
  connect?: Maybe<RigImageWhereUniqueInput>;
}

export interface RigImageCreateInput {
  id?: Maybe<ID_Input>;
  image?: Maybe<CloudinaryImageCreateOneInput>;
}

export interface VehicleCreateOneInput {
  create?: Maybe<VehicleCreateInput>;
  connect?: Maybe<VehicleWhereUniqueInput>;
}

export interface VehicleCreateInput {
  id?: Maybe<ID_Input>;
  year: Int;
  make: String;
  model: String;
  name?: Maybe<String>;
  trim?: Maybe<String>;
  image?: Maybe<CloudinaryImageCreateOneInput>;
  outfitLevel?: Maybe<OutfitLevel>;
  mods?: Maybe<VehicleCreatemodsInput>;
}

export interface VehicleCreatemodsInput {
  set?: Maybe<String[] | String>;
}

export interface BallotCreateManyWithoutCandidatesInput {
  create?: Maybe<
    BallotCreateWithoutCandidatesInput[] | BallotCreateWithoutCandidatesInput
  >;
  connect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
}

export interface BallotCreateWithoutCandidatesInput {
  id?: Maybe<ID_Input>;
  title: String;
  desc?: Maybe<String>;
  votes?: Maybe<VoteCreateManyWithoutBallotInput>;
}

export interface VoteCreateManyWithoutBallotInput {
  create?: Maybe<VoteCreateWithoutBallotInput[] | VoteCreateWithoutBallotInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutBallotInput {
  id?: Maybe<ID_Input>;
  candidate?: Maybe<UserCreateOneWithoutVotesReceivedInput>;
  voter: UserCreateOneWithoutVotedForInput;
}

export interface UserCreateOneWithoutVotesReceivedInput {
  create?: Maybe<UserCreateWithoutVotesReceivedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutVotesReceivedInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface VoteCreateManyWithoutVoterInput {
  create?: Maybe<VoteCreateWithoutVoterInput[] | VoteCreateWithoutVoterInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutVoterInput {
  id?: Maybe<ID_Input>;
  ballot: BallotCreateOneWithoutVotesInput;
  candidate?: Maybe<UserCreateOneWithoutVotesReceivedInput>;
}

export interface BallotCreateOneWithoutVotesInput {
  create?: Maybe<BallotCreateWithoutVotesInput>;
  connect?: Maybe<BallotWhereUniqueInput>;
}

export interface BallotCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  title: String;
  desc?: Maybe<String>;
  candidates?: Maybe<UserCreateManyWithoutCandidateForInput>;
}

export interface UserCreateManyWithoutCandidateForInput {
  create?: Maybe<
    UserCreateWithoutCandidateForInput[] | UserCreateWithoutCandidateForInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutCandidateForInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface VoteCreateManyWithoutCandidateInput {
  create?: Maybe<
    VoteCreateWithoutCandidateInput[] | VoteCreateWithoutCandidateInput
  >;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutCandidateInput {
  id?: Maybe<ID_Input>;
  ballot: BallotCreateOneWithoutVotesInput;
  voter: UserCreateOneWithoutVotedForInput;
}

export interface UserCreateOneWithoutVotedForInput {
  create?: Maybe<UserCreateWithoutVotedForInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutVotedForInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface ActivityLogItemCreateManyWithoutUserInput {
  create?: Maybe<
    | ActivityLogItemCreateWithoutUserInput[]
    | ActivityLogItemCreateWithoutUserInput
  >;
  connect?: Maybe<
    ActivityLogItemWhereUniqueInput[] | ActivityLogItemWhereUniqueInput
  >;
}

export interface ActivityLogItemCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  time: DateTimeInput;
  message: String;
  messageCode: ActivityMessageCode;
  link?: Maybe<String>;
}

export interface MembershipLogItemCreateManyWithoutUserInput {
  create?: Maybe<
    | MembershipLogItemCreateWithoutUserInput[]
    | MembershipLogItemCreateWithoutUserInput
  >;
  connect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
}

export interface MembershipLogItemCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  time: DateTimeInput;
  message: String;
  messageCode: MembershipMessageCode;
  logger?: Maybe<UserCreateOneWithoutMembershipLogContributionsInput>;
}

export interface UserCreateOneWithoutMembershipLogContributionsInput {
  create?: Maybe<UserCreateWithoutMembershipLogContributionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMembershipLogContributionsInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface EventCreateManyWithoutCreatorInput {
  create?: Maybe<
    EventCreateWithoutCreatorInput[] | EventCreateWithoutCreatorInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutCreatorInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutEventsHostedInput {
  create?: Maybe<UserCreateWithoutEventsHostedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEventsHostedInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface MembershipLogItemCreateManyWithoutLoggerInput {
  create?: Maybe<
    | MembershipLogItemCreateWithoutLoggerInput[]
    | MembershipLogItemCreateWithoutLoggerInput
  >;
  connect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
}

export interface MembershipLogItemCreateWithoutLoggerInput {
  id?: Maybe<ID_Input>;
  time: DateTimeInput;
  message: String;
  messageCode: MembershipMessageCode;
  user: UserCreateOneWithoutMembershipLogInput;
}

export interface UserCreateOneWithoutMembershipLogInput {
  create?: Maybe<UserCreateWithoutMembershipLogInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMembershipLogInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface RSVPCreateManyWithoutMemberInput {
  create?: Maybe<RSVPCreateWithoutMemberInput[] | RSVPCreateWithoutMemberInput>;
  connect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
}

export interface RSVPCreateWithoutMemberInput {
  id?: Maybe<ID_Input>;
  event: EventCreateOneWithoutRsvpsInput;
  status?: Maybe<RSVPStatus>;
}

export interface EventCreateOneWithoutRsvpsInput {
  create?: Maybe<EventCreateWithoutRsvpsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutRsvpsInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutEventsCreatedInput {
  create?: Maybe<UserCreateWithoutEventsCreatedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEventsCreatedInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface EventCreateManyWithoutHostInput {
  create?: Maybe<EventCreateWithoutHostInput[] | EventCreateWithoutHostInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutHostInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface RSVPCreateManyWithoutEventInput {
  create?: Maybe<RSVPCreateWithoutEventInput[] | RSVPCreateWithoutEventInput>;
  connect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
}

export interface RSVPCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  member: UserCreateOneWithoutEventsRSVPdInput;
  status?: Maybe<RSVPStatus>;
}

export interface UserCreateOneWithoutEventsRSVPdInput {
  create?: Maybe<UserCreateWithoutEventsRSVPdInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEventsRSVPdInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface TrailCreateManyWithoutVisitorsInput {
  create?: Maybe<
    TrailCreateWithoutVisitorsInput[] | TrailCreateWithoutVisitorsInput
  >;
  connect?: Maybe<TrailWhereUniqueInput[] | TrailWhereUniqueInput>;
}

export interface TrailCreateWithoutVisitorsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventCreateManyWithoutTrailInput>;
  runReports?: Maybe<RunReportCreateManyWithoutTrailInput>;
}

export interface EventCreateManyWithoutTrailInput {
  create?: Maybe<EventCreateWithoutTrailInput[] | EventCreateWithoutTrailInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutTrailInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface BandaidCreateManyWithoutEventInput {
  create?: Maybe<
    BandaidCreateWithoutEventInput[] | BandaidCreateWithoutEventInput
  >;
  connect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
}

export interface BandaidCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  memberInvolved?: Maybe<UserCreateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserCreateOneWithoutBandaidsInput {
  create?: Maybe<UserCreateWithoutBandaidsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutBandaidsInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface RunReportCreateManyWithoutReporterInput {
  create?: Maybe<
    RunReportCreateWithoutReporterInput[] | RunReportCreateWithoutReporterInput
  >;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
}

export interface RunReportCreateWithoutReporterInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reportFiled: DateTimeInput;
  title: String;
  description?: Maybe<String>;
  trail: TrailCreateOneWithoutRunReportsInput;
  event?: Maybe<EventCreateOneWithoutRunReportsInput>;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  condition?: Maybe<ConditionCreateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface TrailCreateOneWithoutRunReportsInput {
  create?: Maybe<TrailCreateWithoutRunReportsInput>;
  connect?: Maybe<TrailWhereUniqueInput>;
}

export interface TrailCreateWithoutRunReportsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventCreateManyWithoutTrailInput>;
  visitors?: Maybe<UserCreateManyWithoutTrailsVisitedInput>;
}

export interface UserCreateManyWithoutTrailsVisitedInput {
  create?: Maybe<
    UserCreateWithoutTrailsVisitedInput[] | UserCreateWithoutTrailsVisitedInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutTrailsVisitedInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface BandaidCreateManyWithoutMemberInvolvedInput {
  create?: Maybe<
    | BandaidCreateWithoutMemberInvolvedInput[]
    | BandaidCreateWithoutMemberInvolvedInput
  >;
  connect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
}

export interface BandaidCreateWithoutMemberInvolvedInput {
  id?: Maybe<ID_Input>;
  event?: Maybe<EventCreateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface EventCreateOneWithoutBandaidsInput {
  create?: Maybe<EventCreateWithoutBandaidsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutBandaidsInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface TrailCreateOneWithoutPastEventsInput {
  create?: Maybe<TrailCreateWithoutPastEventsInput>;
  connect?: Maybe<TrailWhereUniqueInput>;
}

export interface TrailCreateWithoutPastEventsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  visitors?: Maybe<UserCreateManyWithoutTrailsVisitedInput>;
  runReports?: Maybe<RunReportCreateManyWithoutTrailInput>;
}

export interface RunReportCreateManyWithoutTrailInput {
  create?: Maybe<
    RunReportCreateWithoutTrailInput[] | RunReportCreateWithoutTrailInput
  >;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
}

export interface RunReportCreateWithoutTrailInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reportFiled: DateTimeInput;
  reporter: UserCreateOneWithoutRunReportsLoggedInput;
  title: String;
  description?: Maybe<String>;
  event?: Maybe<EventCreateOneWithoutRunReportsInput>;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  condition?: Maybe<ConditionCreateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutRunReportsLoggedInput {
  create?: Maybe<UserCreateWithoutRunReportsLoggedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutRunReportsLoggedInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
}

export interface EventCreateOneWithoutRunReportsInput {
  create?: Maybe<EventCreateWithoutRunReportsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutRunReportsInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface ConditionCreateOneWithoutReportInput {
  create?: Maybe<ConditionCreateWithoutReportInput>;
  connect?: Maybe<ConditionWhereUniqueInput>;
}

export interface ConditionCreateWithoutReportInput {
  id?: Maybe<ID_Input>;
  status: TrailCondition;
  notes?: Maybe<String>;
}

export interface RunReportCreateManyWithoutEventInput {
  create?: Maybe<
    RunReportCreateWithoutEventInput[] | RunReportCreateWithoutEventInput
  >;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
}

export interface RunReportCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reportFiled: DateTimeInput;
  reporter: UserCreateOneWithoutRunReportsLoggedInput;
  title: String;
  description?: Maybe<String>;
  trail: TrailCreateOneWithoutRunReportsInput;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  condition?: Maybe<ConditionCreateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface ActivityLogItemUpdateInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  user?: Maybe<UserUpdateOneRequiredWithoutActivityLogInput>;
  link?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutActivityLogInput {
  create?: Maybe<UserCreateWithoutActivityLogInput>;
  update?: Maybe<UserUpdateWithoutActivityLogDataInput>;
  upsert?: Maybe<UserUpsertWithoutActivityLogInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutActivityLogDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface ContactInfoUpdateOneWithoutUserInput {
  create?: Maybe<ContactInfoCreateWithoutUserInput>;
  update?: Maybe<ContactInfoUpdateWithoutUserDataInput>;
  upsert?: Maybe<ContactInfoUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContactInfoWhereUniqueInput>;
}

export interface ContactInfoUpdateWithoutUserDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface ContactInfoUpsertWithoutUserInput {
  update: ContactInfoUpdateWithoutUserDataInput;
  create: ContactInfoCreateWithoutUserInput;
}

export interface PreferenceUpdateOneWithoutUserInput {
  create?: Maybe<PreferenceCreateWithoutUserInput>;
  update?: Maybe<PreferenceUpdateWithoutUserDataInput>;
  upsert?: Maybe<PreferenceUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PreferenceWhereUniqueInput>;
}

export interface PreferenceUpdateWithoutUserDataInput {
  emergencyContactName?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
}

export interface PreferenceUpsertWithoutUserInput {
  update: PreferenceUpdateWithoutUserDataInput;
  create: PreferenceCreateWithoutUserInput;
}

export interface UserMetaUpdateOneWithoutUserInput {
  create?: Maybe<UserMetaCreateWithoutUserInput>;
  update?: Maybe<UserMetaUpdateWithoutUserDataInput>;
  upsert?: Maybe<UserMetaUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserMetaWhereUniqueInput>;
}

export interface UserMetaUpdateWithoutUserDataInput {
  emailVerified?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
}

export interface UserMetaUpsertWithoutUserInput {
  update: UserMetaUpdateWithoutUserDataInput;
  create: UserMetaCreateWithoutUserInput;
}

export interface CloudinaryImageUpdateOneInput {
  create?: Maybe<CloudinaryImageCreateInput>;
  update?: Maybe<CloudinaryImageUpdateDataInput>;
  upsert?: Maybe<CloudinaryImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CloudinaryImageWhereUniqueInput>;
}

export interface CloudinaryImageUpdateDataInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
  smallUrl?: Maybe<String>;
}

export interface CloudinaryImageUpsertNestedInput {
  update: CloudinaryImageUpdateDataInput;
  create: CloudinaryImageCreateInput;
}

export interface RigImageUpdateOneInput {
  create?: Maybe<RigImageCreateInput>;
  update?: Maybe<RigImageUpdateDataInput>;
  upsert?: Maybe<RigImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RigImageWhereUniqueInput>;
}

export interface RigImageUpdateDataInput {
  image?: Maybe<CloudinaryImageUpdateOneInput>;
}

export interface RigImageUpsertNestedInput {
  update: RigImageUpdateDataInput;
  create: RigImageCreateInput;
}

export interface VehicleUpdateOneInput {
  create?: Maybe<VehicleCreateInput>;
  update?: Maybe<VehicleUpdateDataInput>;
  upsert?: Maybe<VehicleUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VehicleWhereUniqueInput>;
}

export interface VehicleUpdateDataInput {
  year?: Maybe<Int>;
  make?: Maybe<String>;
  model?: Maybe<String>;
  name?: Maybe<String>;
  trim?: Maybe<String>;
  image?: Maybe<CloudinaryImageUpdateOneInput>;
  outfitLevel?: Maybe<OutfitLevel>;
  mods?: Maybe<VehicleUpdatemodsInput>;
}

export interface VehicleUpdatemodsInput {
  set?: Maybe<String[] | String>;
}

export interface VehicleUpsertNestedInput {
  update: VehicleUpdateDataInput;
  create: VehicleCreateInput;
}

export interface BallotUpdateManyWithoutCandidatesInput {
  create?: Maybe<
    BallotCreateWithoutCandidatesInput[] | BallotCreateWithoutCandidatesInput
  >;
  delete?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  connect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  set?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  disconnect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  update?: Maybe<
    | BallotUpdateWithWhereUniqueWithoutCandidatesInput[]
    | BallotUpdateWithWhereUniqueWithoutCandidatesInput
  >;
  upsert?: Maybe<
    | BallotUpsertWithWhereUniqueWithoutCandidatesInput[]
    | BallotUpsertWithWhereUniqueWithoutCandidatesInput
  >;
  deleteMany?: Maybe<BallotScalarWhereInput[] | BallotScalarWhereInput>;
  updateMany?: Maybe<
    | BallotUpdateManyWithWhereNestedInput[]
    | BallotUpdateManyWithWhereNestedInput
  >;
}

export interface BallotUpdateWithWhereUniqueWithoutCandidatesInput {
  where: BallotWhereUniqueInput;
  data: BallotUpdateWithoutCandidatesDataInput;
}

export interface BallotUpdateWithoutCandidatesDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
  votes?: Maybe<VoteUpdateManyWithoutBallotInput>;
}

export interface VoteUpdateManyWithoutBallotInput {
  create?: Maybe<VoteCreateWithoutBallotInput[] | VoteCreateWithoutBallotInput>;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutBallotInput[]
    | VoteUpdateWithWhereUniqueWithoutBallotInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutBallotInput[]
    | VoteUpsertWithWhereUniqueWithoutBallotInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
}

export interface VoteUpdateWithWhereUniqueWithoutBallotInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutBallotDataInput;
}

export interface VoteUpdateWithoutBallotDataInput {
  candidate?: Maybe<UserUpdateOneWithoutVotesReceivedInput>;
  voter?: Maybe<UserUpdateOneRequiredWithoutVotedForInput>;
}

export interface UserUpdateOneWithoutVotesReceivedInput {
  create?: Maybe<UserCreateWithoutVotesReceivedInput>;
  update?: Maybe<UserUpdateWithoutVotesReceivedDataInput>;
  upsert?: Maybe<UserUpsertWithoutVotesReceivedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutVotesReceivedDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface VoteUpdateManyWithoutVoterInput {
  create?: Maybe<VoteCreateWithoutVoterInput[] | VoteCreateWithoutVoterInput>;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutVoterInput[]
    | VoteUpdateWithWhereUniqueWithoutVoterInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutVoterInput[]
    | VoteUpsertWithWhereUniqueWithoutVoterInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
}

export interface VoteUpdateWithWhereUniqueWithoutVoterInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutVoterDataInput;
}

export interface VoteUpdateWithoutVoterDataInput {
  ballot?: Maybe<BallotUpdateOneRequiredWithoutVotesInput>;
  candidate?: Maybe<UserUpdateOneWithoutVotesReceivedInput>;
}

export interface BallotUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<BallotCreateWithoutVotesInput>;
  update?: Maybe<BallotUpdateWithoutVotesDataInput>;
  upsert?: Maybe<BallotUpsertWithoutVotesInput>;
  connect?: Maybe<BallotWhereUniqueInput>;
}

export interface BallotUpdateWithoutVotesDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
  candidates?: Maybe<UserUpdateManyWithoutCandidateForInput>;
}

export interface UserUpdateManyWithoutCandidateForInput {
  create?: Maybe<
    UserCreateWithoutCandidateForInput[] | UserCreateWithoutCandidateForInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCandidateForInput[]
    | UserUpdateWithWhereUniqueWithoutCandidateForInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCandidateForInput[]
    | UserUpsertWithWhereUniqueWithoutCandidateForInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutCandidateForInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCandidateForDataInput;
}

export interface UserUpdateWithoutCandidateForDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface VoteUpdateManyWithoutCandidateInput {
  create?: Maybe<
    VoteCreateWithoutCandidateInput[] | VoteCreateWithoutCandidateInput
  >;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutCandidateInput[]
    | VoteUpdateWithWhereUniqueWithoutCandidateInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutCandidateInput[]
    | VoteUpsertWithWhereUniqueWithoutCandidateInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
}

export interface VoteUpdateWithWhereUniqueWithoutCandidateInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutCandidateDataInput;
}

export interface VoteUpdateWithoutCandidateDataInput {
  ballot?: Maybe<BallotUpdateOneRequiredWithoutVotesInput>;
  voter?: Maybe<UserUpdateOneRequiredWithoutVotedForInput>;
}

export interface UserUpdateOneRequiredWithoutVotedForInput {
  create?: Maybe<UserCreateWithoutVotedForInput>;
  update?: Maybe<UserUpdateWithoutVotedForDataInput>;
  upsert?: Maybe<UserUpsertWithoutVotedForInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutVotedForDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface ActivityLogItemUpdateManyWithoutUserInput {
  create?: Maybe<
    | ActivityLogItemCreateWithoutUserInput[]
    | ActivityLogItemCreateWithoutUserInput
  >;
  delete?: Maybe<
    ActivityLogItemWhereUniqueInput[] | ActivityLogItemWhereUniqueInput
  >;
  connect?: Maybe<
    ActivityLogItemWhereUniqueInput[] | ActivityLogItemWhereUniqueInput
  >;
  set?: Maybe<
    ActivityLogItemWhereUniqueInput[] | ActivityLogItemWhereUniqueInput
  >;
  disconnect?: Maybe<
    ActivityLogItemWhereUniqueInput[] | ActivityLogItemWhereUniqueInput
  >;
  update?: Maybe<
    | ActivityLogItemUpdateWithWhereUniqueWithoutUserInput[]
    | ActivityLogItemUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ActivityLogItemUpsertWithWhereUniqueWithoutUserInput[]
    | ActivityLogItemUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    ActivityLogItemScalarWhereInput[] | ActivityLogItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ActivityLogItemUpdateManyWithWhereNestedInput[]
    | ActivityLogItemUpdateManyWithWhereNestedInput
  >;
}

export interface ActivityLogItemUpdateWithWhereUniqueWithoutUserInput {
  where: ActivityLogItemWhereUniqueInput;
  data: ActivityLogItemUpdateWithoutUserDataInput;
}

export interface ActivityLogItemUpdateWithoutUserDataInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  link?: Maybe<String>;
}

export interface ActivityLogItemUpsertWithWhereUniqueWithoutUserInput {
  where: ActivityLogItemWhereUniqueInput;
  update: ActivityLogItemUpdateWithoutUserDataInput;
  create: ActivityLogItemCreateWithoutUserInput;
}

export interface ActivityLogItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  messageCode_not?: Maybe<ActivityMessageCode>;
  messageCode_in?: Maybe<ActivityMessageCode[] | ActivityMessageCode>;
  messageCode_not_in?: Maybe<ActivityMessageCode[] | ActivityMessageCode>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ActivityLogItemScalarWhereInput[] | ActivityLogItemScalarWhereInput
  >;
  OR?: Maybe<
    ActivityLogItemScalarWhereInput[] | ActivityLogItemScalarWhereInput
  >;
  NOT?: Maybe<
    ActivityLogItemScalarWhereInput[] | ActivityLogItemScalarWhereInput
  >;
}

export interface ActivityLogItemUpdateManyWithWhereNestedInput {
  where: ActivityLogItemScalarWhereInput;
  data: ActivityLogItemUpdateManyDataInput;
}

export interface ActivityLogItemUpdateManyDataInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  link?: Maybe<String>;
}

export interface MembershipLogItemUpdateManyWithoutUserInput {
  create?: Maybe<
    | MembershipLogItemCreateWithoutUserInput[]
    | MembershipLogItemCreateWithoutUserInput
  >;
  delete?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  connect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  set?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  disconnect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  update?: Maybe<
    | MembershipLogItemUpdateWithWhereUniqueWithoutUserInput[]
    | MembershipLogItemUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MembershipLogItemUpsertWithWhereUniqueWithoutUserInput[]
    | MembershipLogItemUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    MembershipLogItemScalarWhereInput[] | MembershipLogItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | MembershipLogItemUpdateManyWithWhereNestedInput[]
    | MembershipLogItemUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipLogItemUpdateWithWhereUniqueWithoutUserInput {
  where: MembershipLogItemWhereUniqueInput;
  data: MembershipLogItemUpdateWithoutUserDataInput;
}

export interface MembershipLogItemUpdateWithoutUserDataInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
  logger?: Maybe<UserUpdateOneWithoutMembershipLogContributionsInput>;
}

export interface UserUpdateOneWithoutMembershipLogContributionsInput {
  create?: Maybe<UserCreateWithoutMembershipLogContributionsInput>;
  update?: Maybe<UserUpdateWithoutMembershipLogContributionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutMembershipLogContributionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMembershipLogContributionsDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface EventUpdateManyWithoutCreatorInput {
  create?: Maybe<
    EventCreateWithoutCreatorInput[] | EventCreateWithoutCreatorInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    | EventUpdateWithWhereUniqueWithoutCreatorInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    | EventUpsertWithWhereUniqueWithoutCreatorInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutCreatorInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutCreatorDataInput;
}

export interface EventUpdateWithoutCreatorDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface UserUpdateOneWithoutEventsHostedInput {
  create?: Maybe<UserCreateWithoutEventsHostedInput>;
  update?: Maybe<UserUpdateWithoutEventsHostedDataInput>;
  upsert?: Maybe<UserUpsertWithoutEventsHostedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEventsHostedDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface MembershipLogItemUpdateManyWithoutLoggerInput {
  create?: Maybe<
    | MembershipLogItemCreateWithoutLoggerInput[]
    | MembershipLogItemCreateWithoutLoggerInput
  >;
  delete?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  connect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  set?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  disconnect?: Maybe<
    MembershipLogItemWhereUniqueInput[] | MembershipLogItemWhereUniqueInput
  >;
  update?: Maybe<
    | MembershipLogItemUpdateWithWhereUniqueWithoutLoggerInput[]
    | MembershipLogItemUpdateWithWhereUniqueWithoutLoggerInput
  >;
  upsert?: Maybe<
    | MembershipLogItemUpsertWithWhereUniqueWithoutLoggerInput[]
    | MembershipLogItemUpsertWithWhereUniqueWithoutLoggerInput
  >;
  deleteMany?: Maybe<
    MembershipLogItemScalarWhereInput[] | MembershipLogItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | MembershipLogItemUpdateManyWithWhereNestedInput[]
    | MembershipLogItemUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipLogItemUpdateWithWhereUniqueWithoutLoggerInput {
  where: MembershipLogItemWhereUniqueInput;
  data: MembershipLogItemUpdateWithoutLoggerDataInput;
}

export interface MembershipLogItemUpdateWithoutLoggerDataInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipLogInput>;
}

export interface UserUpdateOneRequiredWithoutMembershipLogInput {
  create?: Maybe<UserCreateWithoutMembershipLogInput>;
  update?: Maybe<UserUpdateWithoutMembershipLogDataInput>;
  upsert?: Maybe<UserUpsertWithoutMembershipLogInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMembershipLogDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface RSVPUpdateManyWithoutMemberInput {
  create?: Maybe<RSVPCreateWithoutMemberInput[] | RSVPCreateWithoutMemberInput>;
  delete?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  connect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  set?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  disconnect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  update?: Maybe<
    | RSVPUpdateWithWhereUniqueWithoutMemberInput[]
    | RSVPUpdateWithWhereUniqueWithoutMemberInput
  >;
  upsert?: Maybe<
    | RSVPUpsertWithWhereUniqueWithoutMemberInput[]
    | RSVPUpsertWithWhereUniqueWithoutMemberInput
  >;
  deleteMany?: Maybe<RSVPScalarWhereInput[] | RSVPScalarWhereInput>;
  updateMany?: Maybe<
    RSVPUpdateManyWithWhereNestedInput[] | RSVPUpdateManyWithWhereNestedInput
  >;
}

export interface RSVPUpdateWithWhereUniqueWithoutMemberInput {
  where: RSVPWhereUniqueInput;
  data: RSVPUpdateWithoutMemberDataInput;
}

export interface RSVPUpdateWithoutMemberDataInput {
  event?: Maybe<EventUpdateOneRequiredWithoutRsvpsInput>;
  status?: Maybe<RSVPStatus>;
}

export interface EventUpdateOneRequiredWithoutRsvpsInput {
  create?: Maybe<EventCreateWithoutRsvpsInput>;
  update?: Maybe<EventUpdateWithoutRsvpsDataInput>;
  upsert?: Maybe<EventUpsertWithoutRsvpsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutRsvpsDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredWithoutEventsCreatedInput {
  create?: Maybe<UserCreateWithoutEventsCreatedInput>;
  update?: Maybe<UserUpdateWithoutEventsCreatedDataInput>;
  upsert?: Maybe<UserUpsertWithoutEventsCreatedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEventsCreatedDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface EventUpdateManyWithoutHostInput {
  create?: Maybe<EventCreateWithoutHostInput[] | EventCreateWithoutHostInput>;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutHostInput[]
    | EventUpdateWithWhereUniqueWithoutHostInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutHostInput[]
    | EventUpsertWithWhereUniqueWithoutHostInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutHostInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutHostDataInput;
}

export interface EventUpdateWithoutHostDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface RSVPUpdateManyWithoutEventInput {
  create?: Maybe<RSVPCreateWithoutEventInput[] | RSVPCreateWithoutEventInput>;
  delete?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  connect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  set?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  disconnect?: Maybe<RSVPWhereUniqueInput[] | RSVPWhereUniqueInput>;
  update?: Maybe<
    | RSVPUpdateWithWhereUniqueWithoutEventInput[]
    | RSVPUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | RSVPUpsertWithWhereUniqueWithoutEventInput[]
    | RSVPUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<RSVPScalarWhereInput[] | RSVPScalarWhereInput>;
  updateMany?: Maybe<
    RSVPUpdateManyWithWhereNestedInput[] | RSVPUpdateManyWithWhereNestedInput
  >;
}

export interface RSVPUpdateWithWhereUniqueWithoutEventInput {
  where: RSVPWhereUniqueInput;
  data: RSVPUpdateWithoutEventDataInput;
}

export interface RSVPUpdateWithoutEventDataInput {
  member?: Maybe<UserUpdateOneRequiredWithoutEventsRSVPdInput>;
  status?: Maybe<RSVPStatus>;
}

export interface UserUpdateOneRequiredWithoutEventsRSVPdInput {
  create?: Maybe<UserCreateWithoutEventsRSVPdInput>;
  update?: Maybe<UserUpdateWithoutEventsRSVPdDataInput>;
  upsert?: Maybe<UserUpsertWithoutEventsRSVPdInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEventsRSVPdDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface TrailUpdateManyWithoutVisitorsInput {
  create?: Maybe<
    TrailCreateWithoutVisitorsInput[] | TrailCreateWithoutVisitorsInput
  >;
  delete?: Maybe<TrailWhereUniqueInput[] | TrailWhereUniqueInput>;
  connect?: Maybe<TrailWhereUniqueInput[] | TrailWhereUniqueInput>;
  set?: Maybe<TrailWhereUniqueInput[] | TrailWhereUniqueInput>;
  disconnect?: Maybe<TrailWhereUniqueInput[] | TrailWhereUniqueInput>;
  update?: Maybe<
    | TrailUpdateWithWhereUniqueWithoutVisitorsInput[]
    | TrailUpdateWithWhereUniqueWithoutVisitorsInput
  >;
  upsert?: Maybe<
    | TrailUpsertWithWhereUniqueWithoutVisitorsInput[]
    | TrailUpsertWithWhereUniqueWithoutVisitorsInput
  >;
  deleteMany?: Maybe<TrailScalarWhereInput[] | TrailScalarWhereInput>;
  updateMany?: Maybe<
    TrailUpdateManyWithWhereNestedInput[] | TrailUpdateManyWithWhereNestedInput
  >;
}

export interface TrailUpdateWithWhereUniqueWithoutVisitorsInput {
  where: TrailWhereUniqueInput;
  data: TrailUpdateWithoutVisitorsDataInput;
}

export interface TrailUpdateWithoutVisitorsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventUpdateManyWithoutTrailInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutTrailInput>;
}

export interface EventUpdateManyWithoutTrailInput {
  create?: Maybe<EventCreateWithoutTrailInput[] | EventCreateWithoutTrailInput>;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutTrailInput[]
    | EventUpdateWithWhereUniqueWithoutTrailInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutTrailInput[]
    | EventUpsertWithWhereUniqueWithoutTrailInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutTrailInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutTrailDataInput;
}

export interface EventUpdateWithoutTrailDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface BandaidUpdateManyWithoutEventInput {
  create?: Maybe<
    BandaidCreateWithoutEventInput[] | BandaidCreateWithoutEventInput
  >;
  delete?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  connect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  set?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  disconnect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  update?: Maybe<
    | BandaidUpdateWithWhereUniqueWithoutEventInput[]
    | BandaidUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | BandaidUpsertWithWhereUniqueWithoutEventInput[]
    | BandaidUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<BandaidScalarWhereInput[] | BandaidScalarWhereInput>;
  updateMany?: Maybe<
    | BandaidUpdateManyWithWhereNestedInput[]
    | BandaidUpdateManyWithWhereNestedInput
  >;
}

export interface BandaidUpdateWithWhereUniqueWithoutEventInput {
  where: BandaidWhereUniqueInput;
  data: BandaidUpdateWithoutEventDataInput;
}

export interface BandaidUpdateWithoutEventDataInput {
  memberInvolved?: Maybe<UserUpdateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserUpdateOneWithoutBandaidsInput {
  create?: Maybe<UserCreateWithoutBandaidsInput>;
  update?: Maybe<UserUpdateWithoutBandaidsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBandaidsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutBandaidsDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface RunReportUpdateManyWithoutReporterInput {
  create?: Maybe<
    RunReportCreateWithoutReporterInput[] | RunReportCreateWithoutReporterInput
  >;
  delete?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  set?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  disconnect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  update?: Maybe<
    | RunReportUpdateWithWhereUniqueWithoutReporterInput[]
    | RunReportUpdateWithWhereUniqueWithoutReporterInput
  >;
  upsert?: Maybe<
    | RunReportUpsertWithWhereUniqueWithoutReporterInput[]
    | RunReportUpsertWithWhereUniqueWithoutReporterInput
  >;
  deleteMany?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
  updateMany?: Maybe<
    | RunReportUpdateManyWithWhereNestedInput[]
    | RunReportUpdateManyWithWhereNestedInput
  >;
}

export interface RunReportUpdateWithWhereUniqueWithoutReporterInput {
  where: RunReportWhereUniqueInput;
  data: RunReportUpdateWithoutReporterDataInput;
}

export interface RunReportUpdateWithoutReporterDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  trail?: Maybe<TrailUpdateOneRequiredWithoutRunReportsInput>;
  event?: Maybe<EventUpdateOneWithoutRunReportsInput>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  condition?: Maybe<ConditionUpdateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface TrailUpdateOneRequiredWithoutRunReportsInput {
  create?: Maybe<TrailCreateWithoutRunReportsInput>;
  update?: Maybe<TrailUpdateWithoutRunReportsDataInput>;
  upsert?: Maybe<TrailUpsertWithoutRunReportsInput>;
  connect?: Maybe<TrailWhereUniqueInput>;
}

export interface TrailUpdateWithoutRunReportsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventUpdateManyWithoutTrailInput>;
  visitors?: Maybe<UserUpdateManyWithoutTrailsVisitedInput>;
}

export interface UserUpdateManyWithoutTrailsVisitedInput {
  create?: Maybe<
    UserCreateWithoutTrailsVisitedInput[] | UserCreateWithoutTrailsVisitedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutTrailsVisitedInput[]
    | UserUpdateWithWhereUniqueWithoutTrailsVisitedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutTrailsVisitedInput[]
    | UserUpsertWithWhereUniqueWithoutTrailsVisitedInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutTrailsVisitedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTrailsVisitedDataInput;
}

export interface UserUpdateWithoutTrailsVisitedDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface BandaidUpdateManyWithoutMemberInvolvedInput {
  create?: Maybe<
    | BandaidCreateWithoutMemberInvolvedInput[]
    | BandaidCreateWithoutMemberInvolvedInput
  >;
  delete?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  connect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  set?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  disconnect?: Maybe<BandaidWhereUniqueInput[] | BandaidWhereUniqueInput>;
  update?: Maybe<
    | BandaidUpdateWithWhereUniqueWithoutMemberInvolvedInput[]
    | BandaidUpdateWithWhereUniqueWithoutMemberInvolvedInput
  >;
  upsert?: Maybe<
    | BandaidUpsertWithWhereUniqueWithoutMemberInvolvedInput[]
    | BandaidUpsertWithWhereUniqueWithoutMemberInvolvedInput
  >;
  deleteMany?: Maybe<BandaidScalarWhereInput[] | BandaidScalarWhereInput>;
  updateMany?: Maybe<
    | BandaidUpdateManyWithWhereNestedInput[]
    | BandaidUpdateManyWithWhereNestedInput
  >;
}

export interface BandaidUpdateWithWhereUniqueWithoutMemberInvolvedInput {
  where: BandaidWhereUniqueInput;
  data: BandaidUpdateWithoutMemberInvolvedDataInput;
}

export interface BandaidUpdateWithoutMemberInvolvedDataInput {
  event?: Maybe<EventUpdateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface EventUpdateOneWithoutBandaidsInput {
  create?: Maybe<EventCreateWithoutBandaidsInput>;
  update?: Maybe<EventUpdateWithoutBandaidsDataInput>;
  upsert?: Maybe<EventUpsertWithoutBandaidsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutBandaidsDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface TrailUpdateOneWithoutPastEventsInput {
  create?: Maybe<TrailCreateWithoutPastEventsInput>;
  update?: Maybe<TrailUpdateWithoutPastEventsDataInput>;
  upsert?: Maybe<TrailUpsertWithoutPastEventsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TrailWhereUniqueInput>;
}

export interface TrailUpdateWithoutPastEventsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  visitors?: Maybe<UserUpdateManyWithoutTrailsVisitedInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutTrailInput>;
}

export interface RunReportUpdateManyWithoutTrailInput {
  create?: Maybe<
    RunReportCreateWithoutTrailInput[] | RunReportCreateWithoutTrailInput
  >;
  delete?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  set?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  disconnect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  update?: Maybe<
    | RunReportUpdateWithWhereUniqueWithoutTrailInput[]
    | RunReportUpdateWithWhereUniqueWithoutTrailInput
  >;
  upsert?: Maybe<
    | RunReportUpsertWithWhereUniqueWithoutTrailInput[]
    | RunReportUpsertWithWhereUniqueWithoutTrailInput
  >;
  deleteMany?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
  updateMany?: Maybe<
    | RunReportUpdateManyWithWhereNestedInput[]
    | RunReportUpdateManyWithWhereNestedInput
  >;
}

export interface RunReportUpdateWithWhereUniqueWithoutTrailInput {
  where: RunReportWhereUniqueInput;
  data: RunReportUpdateWithoutTrailDataInput;
}

export interface RunReportUpdateWithoutTrailDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reporter?: Maybe<UserUpdateOneRequiredWithoutRunReportsLoggedInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutRunReportsInput>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  condition?: Maybe<ConditionUpdateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredWithoutRunReportsLoggedInput {
  create?: Maybe<UserCreateWithoutRunReportsLoggedInput>;
  update?: Maybe<UserUpdateWithoutRunReportsLoggedDataInput>;
  upsert?: Maybe<UserUpsertWithoutRunReportsLoggedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutRunReportsLoggedDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
}

export interface UserUpsertWithoutRunReportsLoggedInput {
  update: UserUpdateWithoutRunReportsLoggedDataInput;
  create: UserCreateWithoutRunReportsLoggedInput;
}

export interface EventUpdateOneWithoutRunReportsInput {
  create?: Maybe<EventCreateWithoutRunReportsInput>;
  update?: Maybe<EventUpdateWithoutRunReportsDataInput>;
  upsert?: Maybe<EventUpsertWithoutRunReportsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutRunReportsDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface EventUpsertWithoutRunReportsInput {
  update: EventUpdateWithoutRunReportsDataInput;
  create: EventCreateWithoutRunReportsInput;
}

export interface ConditionUpdateOneWithoutReportInput {
  create?: Maybe<ConditionCreateWithoutReportInput>;
  update?: Maybe<ConditionUpdateWithoutReportDataInput>;
  upsert?: Maybe<ConditionUpsertWithoutReportInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ConditionWhereUniqueInput>;
}

export interface ConditionUpdateWithoutReportDataInput {
  status?: Maybe<TrailCondition>;
  notes?: Maybe<String>;
}

export interface ConditionUpsertWithoutReportInput {
  update: ConditionUpdateWithoutReportDataInput;
  create: ConditionCreateWithoutReportInput;
}

export interface RunReportUpsertWithWhereUniqueWithoutTrailInput {
  where: RunReportWhereUniqueInput;
  update: RunReportUpdateWithoutTrailDataInput;
  create: RunReportCreateWithoutTrailInput;
}

export interface RunReportScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reportFiled_not?: Maybe<DateTimeInput>;
  reportFiled_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportFiled_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportFiled_lt?: Maybe<DateTimeInput>;
  reportFiled_lte?: Maybe<DateTimeInput>;
  reportFiled_gt?: Maybe<DateTimeInput>;
  reportFiled_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  weather?: Maybe<String>;
  weather_not?: Maybe<String>;
  weather_in?: Maybe<String[] | String>;
  weather_not_in?: Maybe<String[] | String>;
  weather_lt?: Maybe<String>;
  weather_lte?: Maybe<String>;
  weather_gt?: Maybe<String>;
  weather_gte?: Maybe<String>;
  weather_contains?: Maybe<String>;
  weather_not_contains?: Maybe<String>;
  weather_starts_with?: Maybe<String>;
  weather_not_starts_with?: Maybe<String>;
  weather_ends_with?: Maybe<String>;
  weather_not_ends_with?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  difficulty_not?: Maybe<TrailDifficulty>;
  difficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  difficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  favorite?: Maybe<Boolean>;
  favorite_not?: Maybe<Boolean>;
  AND?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
  OR?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
  NOT?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
}

export interface RunReportUpdateManyWithWhereNestedInput {
  where: RunReportScalarWhereInput;
  data: RunReportUpdateManyDataInput;
}

export interface RunReportUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  favorite?: Maybe<Boolean>;
}

export interface TrailUpsertWithoutPastEventsInput {
  update: TrailUpdateWithoutPastEventsDataInput;
  create: TrailCreateWithoutPastEventsInput;
}

export interface RunReportUpdateManyWithoutEventInput {
  create?: Maybe<
    RunReportCreateWithoutEventInput[] | RunReportCreateWithoutEventInput
  >;
  delete?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  connect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  set?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  disconnect?: Maybe<RunReportWhereUniqueInput[] | RunReportWhereUniqueInput>;
  update?: Maybe<
    | RunReportUpdateWithWhereUniqueWithoutEventInput[]
    | RunReportUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | RunReportUpsertWithWhereUniqueWithoutEventInput[]
    | RunReportUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<RunReportScalarWhereInput[] | RunReportScalarWhereInput>;
  updateMany?: Maybe<
    | RunReportUpdateManyWithWhereNestedInput[]
    | RunReportUpdateManyWithWhereNestedInput
  >;
}

export interface RunReportUpdateWithWhereUniqueWithoutEventInput {
  where: RunReportWhereUniqueInput;
  data: RunReportUpdateWithoutEventDataInput;
}

export interface RunReportUpdateWithoutEventDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reporter?: Maybe<UserUpdateOneRequiredWithoutRunReportsLoggedInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  trail?: Maybe<TrailUpdateOneRequiredWithoutRunReportsInput>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  condition?: Maybe<ConditionUpdateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface RunReportUpsertWithWhereUniqueWithoutEventInput {
  where: RunReportWhereUniqueInput;
  update: RunReportUpdateWithoutEventDataInput;
  create: RunReportCreateWithoutEventInput;
}

export interface EventUpsertWithoutBandaidsInput {
  update: EventUpdateWithoutBandaidsDataInput;
  create: EventCreateWithoutBandaidsInput;
}

export interface BandaidUpsertWithWhereUniqueWithoutMemberInvolvedInput {
  where: BandaidWhereUniqueInput;
  update: BandaidUpdateWithoutMemberInvolvedDataInput;
  create: BandaidCreateWithoutMemberInvolvedInput;
}

export interface BandaidScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BandaidScalarWhereInput[] | BandaidScalarWhereInput>;
  OR?: Maybe<BandaidScalarWhereInput[] | BandaidScalarWhereInput>;
  NOT?: Maybe<BandaidScalarWhereInput[] | BandaidScalarWhereInput>;
}

export interface BandaidUpdateManyWithWhereNestedInput {
  where: BandaidScalarWhereInput;
  data: BandaidUpdateManyDataInput;
}

export interface BandaidUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutTrailsVisitedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTrailsVisitedDataInput;
  create: UserCreateWithoutTrailsVisitedInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  joined?: Maybe<DateTimeInput>;
  joined_not?: Maybe<DateTimeInput>;
  joined_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joined_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joined_lt?: Maybe<DateTimeInput>;
  joined_lte?: Maybe<DateTimeInput>;
  joined_gt?: Maybe<DateTimeInput>;
  joined_gte?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  lastLogin_not?: Maybe<DateTimeInput>;
  lastLogin_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastLogin_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastLogin_lt?: Maybe<DateTimeInput>;
  lastLogin_lte?: Maybe<DateTimeInput>;
  lastLogin_gt?: Maybe<DateTimeInput>;
  lastLogin_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  birthdate?: Maybe<DateTimeInput>;
  birthdate_not?: Maybe<DateTimeInput>;
  birthdate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthdate_lt?: Maybe<DateTimeInput>;
  birthdate_lte?: Maybe<DateTimeInput>;
  birthdate_gt?: Maybe<DateTimeInput>;
  birthdate_gte?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  isCharterMember?: Maybe<Boolean>;
  isCharterMember_not?: Maybe<Boolean>;
  title?: Maybe<Title>;
  title_not?: Maybe<Title>;
  title_in?: Maybe<Title[] | Title>;
  title_not_in?: Maybe<Title[] | Title>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountStatus_not?: Maybe<AccountStatus>;
  accountStatus_in?: Maybe<AccountStatus[] | AccountStatus>;
  accountStatus_not_in?: Maybe<AccountStatus[] | AccountStatus>;
  accountType?: Maybe<AccountType>;
  accountType_not?: Maybe<AccountType>;
  accountType_in?: Maybe<AccountType[] | AccountType>;
  accountType_not_in?: Maybe<AccountType[] | AccountType>;
  office?: Maybe<Office>;
  office_not?: Maybe<Office>;
  office_in?: Maybe<Office[] | Office>;
  office_not_in?: Maybe<Office[] | Office>;
  comfortLevel?: Maybe<String>;
  comfortLevel_not?: Maybe<String>;
  comfortLevel_in?: Maybe<String[] | String>;
  comfortLevel_not_in?: Maybe<String[] | String>;
  comfortLevel_lt?: Maybe<String>;
  comfortLevel_lte?: Maybe<String>;
  comfortLevel_gt?: Maybe<String>;
  comfortLevel_gte?: Maybe<String>;
  comfortLevel_contains?: Maybe<String>;
  comfortLevel_not_contains?: Maybe<String>;
  comfortLevel_starts_with?: Maybe<String>;
  comfortLevel_not_starts_with?: Maybe<String>;
  comfortLevel_ends_with?: Maybe<String>;
  comfortLevel_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  isCharterMember?: Maybe<Boolean>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  comfortLevel?: Maybe<String>;
}

export interface TrailUpsertWithoutRunReportsInput {
  update: TrailUpdateWithoutRunReportsDataInput;
  create: TrailCreateWithoutRunReportsInput;
}

export interface RunReportUpsertWithWhereUniqueWithoutReporterInput {
  where: RunReportWhereUniqueInput;
  update: RunReportUpdateWithoutReporterDataInput;
  create: RunReportCreateWithoutReporterInput;
}

export interface UserUpsertWithoutBandaidsInput {
  update: UserUpdateWithoutBandaidsDataInput;
  create: UserCreateWithoutBandaidsInput;
}

export interface BandaidUpsertWithWhereUniqueWithoutEventInput {
  where: BandaidWhereUniqueInput;
  update: BandaidUpdateWithoutEventDataInput;
  create: BandaidCreateWithoutEventInput;
}

export interface EventUpsertWithWhereUniqueWithoutTrailInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutTrailDataInput;
  create: EventCreateWithoutTrailInput;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<EventType>;
  type_not?: Maybe<EventType>;
  type_in?: Maybe<EventType[] | EventType>;
  type_not_in?: Maybe<EventType[] | EventType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailDifficulty_not?: Maybe<TrailDifficulty>;
  trailDifficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  trailDifficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  trailNotes?: Maybe<String>;
  trailNotes_not?: Maybe<String>;
  trailNotes_in?: Maybe<String[] | String>;
  trailNotes_not_in?: Maybe<String[] | String>;
  trailNotes_lt?: Maybe<String>;
  trailNotes_lte?: Maybe<String>;
  trailNotes_gt?: Maybe<String>;
  trailNotes_gte?: Maybe<String>;
  trailNotes_contains?: Maybe<String>;
  trailNotes_not_contains?: Maybe<String>;
  trailNotes_starts_with?: Maybe<String>;
  trailNotes_not_starts_with?: Maybe<String>;
  trailNotes_ends_with?: Maybe<String>;
  trailNotes_not_ends_with?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyAddress_not?: Maybe<String>;
  rallyAddress_in?: Maybe<String[] | String>;
  rallyAddress_not_in?: Maybe<String[] | String>;
  rallyAddress_lt?: Maybe<String>;
  rallyAddress_lte?: Maybe<String>;
  rallyAddress_gt?: Maybe<String>;
  rallyAddress_gte?: Maybe<String>;
  rallyAddress_contains?: Maybe<String>;
  rallyAddress_not_contains?: Maybe<String>;
  rallyAddress_starts_with?: Maybe<String>;
  rallyAddress_not_starts_with?: Maybe<String>;
  rallyAddress_ends_with?: Maybe<String>;
  rallyAddress_not_ends_with?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  rallyTime_not?: Maybe<DateTimeInput>;
  rallyTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  rallyTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  rallyTime_lt?: Maybe<DateTimeInput>;
  rallyTime_lte?: Maybe<DateTimeInput>;
  rallyTime_gt?: Maybe<DateTimeInput>;
  rallyTime_gte?: Maybe<DateTimeInput>;
  membersOnly?: Maybe<Boolean>;
  membersOnly_not?: Maybe<Boolean>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface TrailUpsertWithWhereUniqueWithoutVisitorsInput {
  where: TrailWhereUniqueInput;
  update: TrailUpdateWithoutVisitorsDataInput;
  create: TrailCreateWithoutVisitorsInput;
}

export interface TrailScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  trailheadCoords?: Maybe<String>;
  trailheadCoords_not?: Maybe<String>;
  trailheadCoords_in?: Maybe<String[] | String>;
  trailheadCoords_not_in?: Maybe<String[] | String>;
  trailheadCoords_lt?: Maybe<String>;
  trailheadCoords_lte?: Maybe<String>;
  trailheadCoords_gt?: Maybe<String>;
  trailheadCoords_gte?: Maybe<String>;
  trailheadCoords_contains?: Maybe<String>;
  trailheadCoords_not_contains?: Maybe<String>;
  trailheadCoords_starts_with?: Maybe<String>;
  trailheadCoords_not_starts_with?: Maybe<String>;
  trailheadCoords_ends_with?: Maybe<String>;
  trailheadCoords_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgDifficulty_not?: Maybe<TrailDifficulty>;
  avgDifficulty_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  avgDifficulty_not_in?: Maybe<TrailDifficulty[] | TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  avgRatings_not?: Maybe<Float>;
  avgRatings_in?: Maybe<Float[] | Float>;
  avgRatings_not_in?: Maybe<Float[] | Float>;
  avgRatings_lt?: Maybe<Float>;
  avgRatings_lte?: Maybe<Float>;
  avgRatings_gt?: Maybe<Float>;
  avgRatings_gte?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  currentConditions_not?: Maybe<String>;
  currentConditions_in?: Maybe<String[] | String>;
  currentConditions_not_in?: Maybe<String[] | String>;
  currentConditions_lt?: Maybe<String>;
  currentConditions_lte?: Maybe<String>;
  currentConditions_gt?: Maybe<String>;
  currentConditions_gte?: Maybe<String>;
  currentConditions_contains?: Maybe<String>;
  currentConditions_not_contains?: Maybe<String>;
  currentConditions_starts_with?: Maybe<String>;
  currentConditions_not_starts_with?: Maybe<String>;
  currentConditions_ends_with?: Maybe<String>;
  currentConditions_not_ends_with?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  conditionsLastReported_not?: Maybe<DateTimeInput>;
  conditionsLastReported_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  conditionsLastReported_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  conditionsLastReported_lt?: Maybe<DateTimeInput>;
  conditionsLastReported_lte?: Maybe<DateTimeInput>;
  conditionsLastReported_gt?: Maybe<DateTimeInput>;
  conditionsLastReported_gte?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  favoriteCount_not?: Maybe<Int>;
  favoriteCount_in?: Maybe<Int[] | Int>;
  favoriteCount_not_in?: Maybe<Int[] | Int>;
  favoriteCount_lt?: Maybe<Int>;
  favoriteCount_lte?: Maybe<Int>;
  favoriteCount_gt?: Maybe<Int>;
  favoriteCount_gte?: Maybe<Int>;
  AND?: Maybe<TrailScalarWhereInput[] | TrailScalarWhereInput>;
  OR?: Maybe<TrailScalarWhereInput[] | TrailScalarWhereInput>;
  NOT?: Maybe<TrailScalarWhereInput[] | TrailScalarWhereInput>;
}

export interface TrailUpdateManyWithWhereNestedInput {
  where: TrailScalarWhereInput;
  data: TrailUpdateManyDataInput;
}

export interface TrailUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
}

export interface UserUpsertWithoutEventsRSVPdInput {
  update: UserUpdateWithoutEventsRSVPdDataInput;
  create: UserCreateWithoutEventsRSVPdInput;
}

export interface RSVPUpsertWithWhereUniqueWithoutEventInput {
  where: RSVPWhereUniqueInput;
  update: RSVPUpdateWithoutEventDataInput;
  create: RSVPCreateWithoutEventInput;
}

export interface RSVPScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<RSVPStatus>;
  status_not?: Maybe<RSVPStatus>;
  status_in?: Maybe<RSVPStatus[] | RSVPStatus>;
  status_not_in?: Maybe<RSVPStatus[] | RSVPStatus>;
  AND?: Maybe<RSVPScalarWhereInput[] | RSVPScalarWhereInput>;
  OR?: Maybe<RSVPScalarWhereInput[] | RSVPScalarWhereInput>;
  NOT?: Maybe<RSVPScalarWhereInput[] | RSVPScalarWhereInput>;
}

export interface RSVPUpdateManyWithWhereNestedInput {
  where: RSVPScalarWhereInput;
  data: RSVPUpdateManyDataInput;
}

export interface RSVPUpdateManyDataInput {
  status?: Maybe<RSVPStatus>;
}

export interface EventUpsertWithWhereUniqueWithoutHostInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutHostDataInput;
  create: EventCreateWithoutHostInput;
}

export interface UserUpsertWithoutEventsCreatedInput {
  update: UserUpdateWithoutEventsCreatedDataInput;
  create: UserCreateWithoutEventsCreatedInput;
}

export interface EventUpsertWithoutRsvpsInput {
  update: EventUpdateWithoutRsvpsDataInput;
  create: EventCreateWithoutRsvpsInput;
}

export interface RSVPUpsertWithWhereUniqueWithoutMemberInput {
  where: RSVPWhereUniqueInput;
  update: RSVPUpdateWithoutMemberDataInput;
  create: RSVPCreateWithoutMemberInput;
}

export interface UserUpsertWithoutMembershipLogInput {
  update: UserUpdateWithoutMembershipLogDataInput;
  create: UserCreateWithoutMembershipLogInput;
}

export interface MembershipLogItemUpsertWithWhereUniqueWithoutLoggerInput {
  where: MembershipLogItemWhereUniqueInput;
  update: MembershipLogItemUpdateWithoutLoggerDataInput;
  create: MembershipLogItemCreateWithoutLoggerInput;
}

export interface MembershipLogItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
  messageCode_not?: Maybe<MembershipMessageCode>;
  messageCode_in?: Maybe<MembershipMessageCode[] | MembershipMessageCode>;
  messageCode_not_in?: Maybe<MembershipMessageCode[] | MembershipMessageCode>;
  AND?: Maybe<
    MembershipLogItemScalarWhereInput[] | MembershipLogItemScalarWhereInput
  >;
  OR?: Maybe<
    MembershipLogItemScalarWhereInput[] | MembershipLogItemScalarWhereInput
  >;
  NOT?: Maybe<
    MembershipLogItemScalarWhereInput[] | MembershipLogItemScalarWhereInput
  >;
}

export interface MembershipLogItemUpdateManyWithWhereNestedInput {
  where: MembershipLogItemScalarWhereInput;
  data: MembershipLogItemUpdateManyDataInput;
}

export interface MembershipLogItemUpdateManyDataInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
}

export interface UserUpsertWithoutEventsHostedInput {
  update: UserUpdateWithoutEventsHostedDataInput;
  create: UserCreateWithoutEventsHostedInput;
}

export interface EventUpsertWithWhereUniqueWithoutCreatorInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutCreatorDataInput;
  create: EventCreateWithoutCreatorInput;
}

export interface UserUpsertWithoutMembershipLogContributionsInput {
  update: UserUpdateWithoutMembershipLogContributionsDataInput;
  create: UserCreateWithoutMembershipLogContributionsInput;
}

export interface MembershipLogItemUpsertWithWhereUniqueWithoutUserInput {
  where: MembershipLogItemWhereUniqueInput;
  update: MembershipLogItemUpdateWithoutUserDataInput;
  create: MembershipLogItemCreateWithoutUserInput;
}

export interface UserUpsertWithoutVotedForInput {
  update: UserUpdateWithoutVotedForDataInput;
  create: UserCreateWithoutVotedForInput;
}

export interface VoteUpsertWithWhereUniqueWithoutCandidateInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutCandidateDataInput;
  create: VoteCreateWithoutCandidateInput;
}

export interface VoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  OR?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  NOT?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
}

export interface UserUpsertWithWhereUniqueWithoutCandidateForInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCandidateForDataInput;
  create: UserCreateWithoutCandidateForInput;
}

export interface BallotUpsertWithoutVotesInput {
  update: BallotUpdateWithoutVotesDataInput;
  create: BallotCreateWithoutVotesInput;
}

export interface VoteUpsertWithWhereUniqueWithoutVoterInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutVoterDataInput;
  create: VoteCreateWithoutVoterInput;
}

export interface UserUpsertWithoutVotesReceivedInput {
  update: UserUpdateWithoutVotesReceivedDataInput;
  create: UserCreateWithoutVotesReceivedInput;
}

export interface VoteUpsertWithWhereUniqueWithoutBallotInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutBallotDataInput;
  create: VoteCreateWithoutBallotInput;
}

export interface BallotUpsertWithWhereUniqueWithoutCandidatesInput {
  where: BallotWhereUniqueInput;
  update: BallotUpdateWithoutCandidatesDataInput;
  create: BallotCreateWithoutCandidatesInput;
}

export interface BallotScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  AND?: Maybe<BallotScalarWhereInput[] | BallotScalarWhereInput>;
  OR?: Maybe<BallotScalarWhereInput[] | BallotScalarWhereInput>;
  NOT?: Maybe<BallotScalarWhereInput[] | BallotScalarWhereInput>;
}

export interface BallotUpdateManyWithWhereNestedInput {
  where: BallotScalarWhereInput;
  data: BallotUpdateManyDataInput;
}

export interface BallotUpdateManyDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface UserUpsertWithoutActivityLogInput {
  update: UserUpdateWithoutActivityLogDataInput;
  create: UserCreateWithoutActivityLogInput;
}

export interface ActivityLogItemUpdateManyMutationInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<ActivityMessageCode>;
  link?: Maybe<String>;
}

export interface BallotCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  desc?: Maybe<String>;
  candidates?: Maybe<UserCreateManyWithoutCandidateForInput>;
  votes?: Maybe<VoteCreateManyWithoutBallotInput>;
}

export interface BallotUpdateInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
  candidates?: Maybe<UserUpdateManyWithoutCandidateForInput>;
  votes?: Maybe<VoteUpdateManyWithoutBallotInput>;
}

export interface BallotUpdateManyMutationInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface BandaidCreateInput {
  id?: Maybe<ID_Input>;
  event?: Maybe<EventCreateOneWithoutBandaidsInput>;
  memberInvolved?: Maybe<UserCreateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BandaidUpdateInput {
  event?: Maybe<EventUpdateOneWithoutBandaidsInput>;
  memberInvolved?: Maybe<UserUpdateOneWithoutBandaidsInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BandaidUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CloudinaryImageUpdateInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
  smallUrl?: Maybe<String>;
}

export interface CloudinaryImageUpdateManyMutationInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
  smallUrl?: Maybe<String>;
}

export interface ConditionCreateInput {
  id?: Maybe<ID_Input>;
  report: RunReportCreateOneWithoutConditionInput;
  status: TrailCondition;
  notes?: Maybe<String>;
}

export interface RunReportCreateOneWithoutConditionInput {
  create?: Maybe<RunReportCreateWithoutConditionInput>;
  connect?: Maybe<RunReportWhereUniqueInput>;
}

export interface RunReportCreateWithoutConditionInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reportFiled: DateTimeInput;
  reporter: UserCreateOneWithoutRunReportsLoggedInput;
  title: String;
  description?: Maybe<String>;
  trail: TrailCreateOneWithoutRunReportsInput;
  event?: Maybe<EventCreateOneWithoutRunReportsInput>;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  favorite?: Maybe<Boolean>;
}

export interface ConditionUpdateInput {
  report?: Maybe<RunReportUpdateOneRequiredWithoutConditionInput>;
  status?: Maybe<TrailCondition>;
  notes?: Maybe<String>;
}

export interface RunReportUpdateOneRequiredWithoutConditionInput {
  create?: Maybe<RunReportCreateWithoutConditionInput>;
  update?: Maybe<RunReportUpdateWithoutConditionDataInput>;
  upsert?: Maybe<RunReportUpsertWithoutConditionInput>;
  connect?: Maybe<RunReportWhereUniqueInput>;
}

export interface RunReportUpdateWithoutConditionDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reporter?: Maybe<UserUpdateOneRequiredWithoutRunReportsLoggedInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  trail?: Maybe<TrailUpdateOneRequiredWithoutRunReportsInput>;
  event?: Maybe<EventUpdateOneWithoutRunReportsInput>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  favorite?: Maybe<Boolean>;
}

export interface RunReportUpsertWithoutConditionInput {
  update: RunReportUpdateWithoutConditionDataInput;
  create: RunReportCreateWithoutConditionInput;
}

export interface ConditionUpdateManyMutationInput {
  status?: Maybe<TrailCondition>;
  notes?: Maybe<String>;
}

export interface ContactInfoCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutContactInfoInput>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  phone: String;
}

export interface UserCreateOneWithoutContactInfoInput {
  create?: Maybe<UserCreateWithoutContactInfoInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutContactInfoInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface ContactInfoUpdateInput {
  user?: Maybe<UserUpdateOneWithoutContactInfoInput>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface UserUpdateOneWithoutContactInfoInput {
  create?: Maybe<UserCreateWithoutContactInfoInput>;
  update?: Maybe<UserUpdateWithoutContactInfoDataInput>;
  upsert?: Maybe<UserUpsertWithoutContactInfoInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutContactInfoDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface UserUpsertWithoutContactInfoInput {
  update: UserUpdateWithoutContactInfoDataInput;
  create: UserCreateWithoutContactInfoInput;
}

export interface ContactInfoUpdateManyMutationInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface ElectionCreateInput {
  id?: Maybe<ID_Input>;
  electionName: String;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  races?: Maybe<BallotCreateManyInput>;
}

export interface BallotCreateManyInput {
  create?: Maybe<BallotCreateInput[] | BallotCreateInput>;
  connect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
}

export interface ElectionUpdateInput {
  electionName?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  races?: Maybe<BallotUpdateManyInput>;
}

export interface BallotUpdateManyInput {
  create?: Maybe<BallotCreateInput[] | BallotCreateInput>;
  update?: Maybe<
    | BallotUpdateWithWhereUniqueNestedInput[]
    | BallotUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BallotUpsertWithWhereUniqueNestedInput[]
    | BallotUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  connect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  set?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  disconnect?: Maybe<BallotWhereUniqueInput[] | BallotWhereUniqueInput>;
  deleteMany?: Maybe<BallotScalarWhereInput[] | BallotScalarWhereInput>;
  updateMany?: Maybe<
    | BallotUpdateManyWithWhereNestedInput[]
    | BallotUpdateManyWithWhereNestedInput
  >;
}

export interface BallotUpdateWithWhereUniqueNestedInput {
  where: BallotWhereUniqueInput;
  data: BallotUpdateDataInput;
}

export interface BallotUpdateDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
  candidates?: Maybe<UserUpdateManyWithoutCandidateForInput>;
  votes?: Maybe<VoteUpdateManyWithoutBallotInput>;
}

export interface BallotUpsertWithWhereUniqueNestedInput {
  where: BallotWhereUniqueInput;
  update: BallotUpdateDataInput;
  create: BallotCreateInput;
}

export interface ElectionUpdateManyMutationInput {
  electionName?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  type: EventType;
  title: String;
  creator: UserCreateOneWithoutEventsCreatedInput;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserCreateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPCreateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailCreateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutEventInput>;
  runReports?: Maybe<RunReportCreateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface EventUpdateInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsCreatedInput>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  host?: Maybe<UserUpdateOneWithoutEventsHostedInput>;
  rsvps?: Maybe<RSVPUpdateManyWithoutEventInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  trail?: Maybe<TrailUpdateOneWithoutPastEventsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutEventInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutEventInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface EventUpdateManyMutationInput {
  type?: Maybe<EventType>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  address?: Maybe<String>;
  trailDifficulty?: Maybe<TrailDifficulty>;
  trailNotes?: Maybe<String>;
  rallyAddress?: Maybe<String>;
  rallyTime?: Maybe<DateTimeInput>;
  membersOnly?: Maybe<Boolean>;
}

export interface MembershipLogItemCreateInput {
  id?: Maybe<ID_Input>;
  time: DateTimeInput;
  message: String;
  messageCode: MembershipMessageCode;
  user: UserCreateOneWithoutMembershipLogInput;
  logger?: Maybe<UserCreateOneWithoutMembershipLogContributionsInput>;
}

export interface MembershipLogItemUpdateInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipLogInput>;
  logger?: Maybe<UserUpdateOneWithoutMembershipLogContributionsInput>;
}

export interface MembershipLogItemUpdateManyMutationInput {
  time?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  messageCode?: Maybe<MembershipMessageCode>;
}

export interface PreferenceCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutPreferencesInput>;
  emergencyContactName?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPreferencesInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface PreferenceUpdateInput {
  user?: Maybe<UserUpdateOneWithoutPreferencesInput>;
  emergencyContactName?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
}

export interface UserUpdateOneWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  update?: Maybe<UserUpdateWithoutPreferencesDataInput>;
  upsert?: Maybe<UserUpsertWithoutPreferencesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPreferencesDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface UserUpsertWithoutPreferencesInput {
  update: UserUpdateWithoutPreferencesDataInput;
  create: UserCreateWithoutPreferencesInput;
}

export interface PreferenceUpdateManyMutationInput {
  emergencyContactName?: Maybe<String>;
  emergencyContactPhone?: Maybe<String>;
  photoPermissions?: Maybe<Boolean>;
  showPhoneNumber?: Maybe<Boolean>;
}

export interface RSVPCreateInput {
  id?: Maybe<ID_Input>;
  member: UserCreateOneWithoutEventsRSVPdInput;
  event: EventCreateOneWithoutRsvpsInput;
  status?: Maybe<RSVPStatus>;
}

export interface RSVPUpdateInput {
  member?: Maybe<UserUpdateOneRequiredWithoutEventsRSVPdInput>;
  event?: Maybe<EventUpdateOneRequiredWithoutRsvpsInput>;
  status?: Maybe<RSVPStatus>;
}

export interface RSVPUpdateManyMutationInput {
  status?: Maybe<RSVPStatus>;
}

export interface RegistrationCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  source: String;
  token: String;
  tokenExpiry: Float;
}

export interface RegistrationUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  source?: Maybe<String>;
  token?: Maybe<String>;
  tokenExpiry?: Maybe<Float>;
}

export interface RegistrationUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  source?: Maybe<String>;
  token?: Maybe<String>;
  tokenExpiry?: Maybe<Float>;
}

export interface RigImageUpdateInput {
  image?: Maybe<CloudinaryImageUpdateOneInput>;
}

export interface RunReportCreateInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reportFiled: DateTimeInput;
  reporter: UserCreateOneWithoutRunReportsLoggedInput;
  title: String;
  description?: Maybe<String>;
  trail: TrailCreateOneWithoutRunReportsInput;
  event?: Maybe<EventCreateOneWithoutRunReportsInput>;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  condition?: Maybe<ConditionCreateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface RunReportUpdateInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  reporter?: Maybe<UserUpdateOneRequiredWithoutRunReportsLoggedInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  trail?: Maybe<TrailUpdateOneRequiredWithoutRunReportsInput>;
  event?: Maybe<EventUpdateOneWithoutRunReportsInput>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  condition?: Maybe<ConditionUpdateOneWithoutReportInput>;
  favorite?: Maybe<Boolean>;
}

export interface RunReportUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  reportFiled?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  weather?: Maybe<String>;
  difficulty?: Maybe<TrailDifficulty>;
  rating?: Maybe<Float>;
  favorite?: Maybe<Boolean>;
}

export interface TrailCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageCreateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventCreateManyWithoutTrailInput>;
  visitors?: Maybe<UserCreateManyWithoutTrailsVisitedInput>;
  runReports?: Maybe<RunReportCreateManyWithoutTrailInput>;
}

export interface TrailUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  featuredImage?: Maybe<CloudinaryImageUpdateOneInput>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
  pastEvents?: Maybe<EventUpdateManyWithoutTrailInput>;
  visitors?: Maybe<UserUpdateManyWithoutTrailsVisitedInput>;
  runReports?: Maybe<RunReportUpdateManyWithoutTrailInput>;
}

export interface TrailUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  trailheadCoords?: Maybe<String>;
  address?: Maybe<String>;
  avgDifficulty?: Maybe<TrailDifficulty>;
  avgRatings?: Maybe<Float>;
  currentConditions?: Maybe<String>;
  conditionsLastReported?: Maybe<DateTimeInput>;
  favoriteCount?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface UserUpdateInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  userMeta?: Maybe<UserMetaUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface UserUpdateManyMutationInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  isCharterMember?: Maybe<Boolean>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  comfortLevel?: Maybe<String>;
}

export interface UserMetaCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutUserMetaInput>;
  emailVerified?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutUserMetaInput {
  create?: Maybe<UserCreateWithoutUserMetaInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutUserMetaInput {
  id?: Maybe<ID_Input>;
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoCreateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceCreateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageCreateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageCreateOneInput>;
  vehicle?: Maybe<VehicleCreateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotCreateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteCreateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteCreateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemCreateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemCreateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemCreateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventCreateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPCreateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventCreateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailCreateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidCreateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportCreateManyWithoutReporterInput>;
}

export interface UserMetaUpdateInput {
  user?: Maybe<UserUpdateOneWithoutUserMetaInput>;
  emailVerified?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
}

export interface UserUpdateOneWithoutUserMetaInput {
  create?: Maybe<UserCreateWithoutUserMetaInput>;
  update?: Maybe<UserUpdateWithoutUserMetaDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserMetaInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutUserMetaDataInput {
  joined?: Maybe<DateTimeInput>;
  lastLogin?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  birthdate?: Maybe<DateTimeInput>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  contactInfo?: Maybe<ContactInfoUpdateOneWithoutUserInput>;
  preferences?: Maybe<PreferenceUpdateOneWithoutUserInput>;
  avatar?: Maybe<CloudinaryImageUpdateOneInput>;
  isCharterMember?: Maybe<Boolean>;
  rig?: Maybe<RigImageUpdateOneInput>;
  vehicle?: Maybe<VehicleUpdateOneInput>;
  title?: Maybe<Title>;
  role?: Maybe<Role>;
  accountStatus?: Maybe<AccountStatus>;
  accountType?: Maybe<AccountType>;
  office?: Maybe<Office>;
  candidateFor?: Maybe<BallotUpdateManyWithoutCandidatesInput>;
  votesReceived?: Maybe<VoteUpdateManyWithoutCandidateInput>;
  votedFor?: Maybe<VoteUpdateManyWithoutVoterInput>;
  comfortLevel?: Maybe<String>;
  activityLog?: Maybe<ActivityLogItemUpdateManyWithoutUserInput>;
  membershipLog?: Maybe<MembershipLogItemUpdateManyWithoutUserInput>;
  membershipLogContributions?: Maybe<
    MembershipLogItemUpdateManyWithoutLoggerInput
  >;
  eventsCreated?: Maybe<EventUpdateManyWithoutCreatorInput>;
  eventsRSVPd?: Maybe<RSVPUpdateManyWithoutMemberInput>;
  eventsHosted?: Maybe<EventUpdateManyWithoutHostInput>;
  trailsVisited?: Maybe<TrailUpdateManyWithoutVisitorsInput>;
  bandaids?: Maybe<BandaidUpdateManyWithoutMemberInvolvedInput>;
  runReportsLogged?: Maybe<RunReportUpdateManyWithoutReporterInput>;
}

export interface UserUpsertWithoutUserMetaInput {
  update: UserUpdateWithoutUserMetaDataInput;
  create: UserCreateWithoutUserMetaInput;
}

export interface UserMetaUpdateManyMutationInput {
  emailVerified?: Maybe<Boolean>;
  firstLoginComplete?: Maybe<Boolean>;
  accountSetupComplete?: Maybe<Boolean>;
  oldSitemigrationComplete?: Maybe<Boolean>;
}

export interface VehicleUpdateInput {
  year?: Maybe<Int>;
  make?: Maybe<String>;
  model?: Maybe<String>;
  name?: Maybe<String>;
  trim?: Maybe<String>;
  image?: Maybe<CloudinaryImageUpdateOneInput>;
  outfitLevel?: Maybe<OutfitLevel>;
  mods?: Maybe<VehicleUpdatemodsInput>;
}

export interface VehicleUpdateManyMutationInput {
  year?: Maybe<Int>;
  make?: Maybe<String>;
  model?: Maybe<String>;
  name?: Maybe<String>;
  trim?: Maybe<String>;
  outfitLevel?: Maybe<OutfitLevel>;
  mods?: Maybe<VehicleUpdatemodsInput>;
}

export interface VoteCreateInput {
  id?: Maybe<ID_Input>;
  ballot: BallotCreateOneWithoutVotesInput;
  candidate?: Maybe<UserCreateOneWithoutVotesReceivedInput>;
  voter: UserCreateOneWithoutVotedForInput;
}

export interface VoteUpdateInput {
  ballot?: Maybe<BallotUpdateOneRequiredWithoutVotesInput>;
  candidate?: Maybe<UserUpdateOneWithoutVotesReceivedInput>;
  voter?: Maybe<UserUpdateOneRequiredWithoutVotedForInput>;
}

export interface ActivityLogItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityLogItemWhereInput>;
  AND?: Maybe<
    | ActivityLogItemSubscriptionWhereInput[]
    | ActivityLogItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ActivityLogItemSubscriptionWhereInput[]
    | ActivityLogItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ActivityLogItemSubscriptionWhereInput[]
    | ActivityLogItemSubscriptionWhereInput
  >;
}

export interface BallotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BallotWhereInput>;
  AND?: Maybe<BallotSubscriptionWhereInput[] | BallotSubscriptionWhereInput>;
  OR?: Maybe<BallotSubscriptionWhereInput[] | BallotSubscriptionWhereInput>;
  NOT?: Maybe<BallotSubscriptionWhereInput[] | BallotSubscriptionWhereInput>;
}

export interface BandaidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BandaidWhereInput>;
  AND?: Maybe<BandaidSubscriptionWhereInput[] | BandaidSubscriptionWhereInput>;
  OR?: Maybe<BandaidSubscriptionWhereInput[] | BandaidSubscriptionWhereInput>;
  NOT?: Maybe<BandaidSubscriptionWhereInput[] | BandaidSubscriptionWhereInput>;
}

export interface CloudinaryImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CloudinaryImageWhereInput>;
  AND?: Maybe<
    | CloudinaryImageSubscriptionWhereInput[]
    | CloudinaryImageSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CloudinaryImageSubscriptionWhereInput[]
    | CloudinaryImageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CloudinaryImageSubscriptionWhereInput[]
    | CloudinaryImageSubscriptionWhereInput
  >;
}

export interface ConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConditionWhereInput>;
  AND?: Maybe<
    ConditionSubscriptionWhereInput[] | ConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ConditionSubscriptionWhereInput[] | ConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ConditionSubscriptionWhereInput[] | ConditionSubscriptionWhereInput
  >;
}

export interface ContactInfoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactInfoWhereInput>;
  AND?: Maybe<
    ContactInfoSubscriptionWhereInput[] | ContactInfoSubscriptionWhereInput
  >;
  OR?: Maybe<
    ContactInfoSubscriptionWhereInput[] | ContactInfoSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ContactInfoSubscriptionWhereInput[] | ContactInfoSubscriptionWhereInput
  >;
}

export interface ElectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ElectionWhereInput>;
  AND?: Maybe<
    ElectionSubscriptionWhereInput[] | ElectionSubscriptionWhereInput
  >;
  OR?: Maybe<ElectionSubscriptionWhereInput[] | ElectionSubscriptionWhereInput>;
  NOT?: Maybe<
    ElectionSubscriptionWhereInput[] | ElectionSubscriptionWhereInput
  >;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface MembershipLogItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MembershipLogItemWhereInput>;
  AND?: Maybe<
    | MembershipLogItemSubscriptionWhereInput[]
    | MembershipLogItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MembershipLogItemSubscriptionWhereInput[]
    | MembershipLogItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MembershipLogItemSubscriptionWhereInput[]
    | MembershipLogItemSubscriptionWhereInput
  >;
}

export interface PreferenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreferenceWhereInput>;
  AND?: Maybe<
    PreferenceSubscriptionWhereInput[] | PreferenceSubscriptionWhereInput
  >;
  OR?: Maybe<
    PreferenceSubscriptionWhereInput[] | PreferenceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PreferenceSubscriptionWhereInput[] | PreferenceSubscriptionWhereInput
  >;
}

export interface RSVPSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RSVPWhereInput>;
  AND?: Maybe<RSVPSubscriptionWhereInput[] | RSVPSubscriptionWhereInput>;
  OR?: Maybe<RSVPSubscriptionWhereInput[] | RSVPSubscriptionWhereInput>;
  NOT?: Maybe<RSVPSubscriptionWhereInput[] | RSVPSubscriptionWhereInput>;
}

export interface RegistrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
}

export interface RigImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RigImageWhereInput>;
  AND?: Maybe<
    RigImageSubscriptionWhereInput[] | RigImageSubscriptionWhereInput
  >;
  OR?: Maybe<RigImageSubscriptionWhereInput[] | RigImageSubscriptionWhereInput>;
  NOT?: Maybe<
    RigImageSubscriptionWhereInput[] | RigImageSubscriptionWhereInput
  >;
}

export interface RunReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RunReportWhereInput>;
  AND?: Maybe<
    RunReportSubscriptionWhereInput[] | RunReportSubscriptionWhereInput
  >;
  OR?: Maybe<
    RunReportSubscriptionWhereInput[] | RunReportSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RunReportSubscriptionWhereInput[] | RunReportSubscriptionWhereInput
  >;
}

export interface TrailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrailWhereInput>;
  AND?: Maybe<TrailSubscriptionWhereInput[] | TrailSubscriptionWhereInput>;
  OR?: Maybe<TrailSubscriptionWhereInput[] | TrailSubscriptionWhereInput>;
  NOT?: Maybe<TrailSubscriptionWhereInput[] | TrailSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserMetaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserMetaWhereInput>;
  AND?: Maybe<
    UserMetaSubscriptionWhereInput[] | UserMetaSubscriptionWhereInput
  >;
  OR?: Maybe<UserMetaSubscriptionWhereInput[] | UserMetaSubscriptionWhereInput>;
  NOT?: Maybe<
    UserMetaSubscriptionWhereInput[] | UserMetaSubscriptionWhereInput
  >;
}

export interface VehicleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VehicleWhereInput>;
  AND?: Maybe<VehicleSubscriptionWhereInput[] | VehicleSubscriptionWhereInput>;
  OR?: Maybe<VehicleSubscriptionWhereInput[] | VehicleSubscriptionWhereInput>;
  NOT?: Maybe<VehicleSubscriptionWhereInput[] | VehicleSubscriptionWhereInput>;
}

export interface VoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoteWhereInput>;
  AND?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  OR?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  NOT?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ActivityLogItem {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
  message: String;
  messageCode: ActivityMessageCode;
  link?: String;
}

export interface ActivityLogItemPromise
  extends Promise<ActivityLogItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<ActivityMessageCode>;
  user: <T = UserPromise>() => T;
  link: () => Promise<String>;
}

export interface ActivityLogItemSubscription
  extends Promise<AsyncIterator<ActivityLogItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  messageCode: () => Promise<AsyncIterator<ActivityMessageCode>>;
  user: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
}

export interface ActivityLogItemNullablePromise
  extends Promise<ActivityLogItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<ActivityMessageCode>;
  user: <T = UserPromise>() => T;
  link: () => Promise<String>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  joined?: DateTimeOutput;
  lastLogin?: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Gender;
  birthdate?: DateTimeOutput;
  username: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  isCharterMember?: Boolean;
  title?: Title;
  role: Role;
  accountStatus: AccountStatus;
  accountType: AccountType;
  office?: Office;
  comfortLevel?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  joined: () => Promise<DateTimeOutput>;
  lastLogin: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  birthdate: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  contactInfo: <T = ContactInfoPromise>() => T;
  preferences: <T = PreferencePromise>() => T;
  userMeta: <T = UserMetaPromise>() => T;
  avatar: <T = CloudinaryImagePromise>() => T;
  isCharterMember: () => Promise<Boolean>;
  rig: <T = RigImagePromise>() => T;
  vehicle: <T = VehiclePromise>() => T;
  title: () => Promise<Title>;
  role: () => Promise<Role>;
  accountStatus: () => Promise<AccountStatus>;
  accountType: () => Promise<AccountType>;
  office: () => Promise<Office>;
  candidateFor: <T = FragmentableArray<Ballot>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votesReceived: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votedFor: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comfortLevel: () => Promise<String>;
  activityLog: <T = FragmentableArray<ActivityLogItem>>(args?: {
    where?: ActivityLogItemWhereInput;
    orderBy?: ActivityLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLog: <T = FragmentableArray<MembershipLogItem>>(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLogContributions: <
    T = FragmentableArray<MembershipLogItem>
  >(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsCreated: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsRSVPd: <T = FragmentableArray<RSVP>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsHosted: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  trailsVisited: <T = FragmentableArray<Trail>>(args?: {
    where?: TrailWhereInput;
    orderBy?: TrailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bandaids: <T = FragmentableArray<Bandaid>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReportsLogged: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  joined: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  contactInfo: <T = ContactInfoSubscription>() => T;
  preferences: <T = PreferenceSubscription>() => T;
  userMeta: <T = UserMetaSubscription>() => T;
  avatar: <T = CloudinaryImageSubscription>() => T;
  isCharterMember: () => Promise<AsyncIterator<Boolean>>;
  rig: <T = RigImageSubscription>() => T;
  vehicle: <T = VehicleSubscription>() => T;
  title: () => Promise<AsyncIterator<Title>>;
  role: () => Promise<AsyncIterator<Role>>;
  accountStatus: () => Promise<AsyncIterator<AccountStatus>>;
  accountType: () => Promise<AsyncIterator<AccountType>>;
  office: () => Promise<AsyncIterator<Office>>;
  candidateFor: <T = Promise<AsyncIterator<BallotSubscription>>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votesReceived: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votedFor: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comfortLevel: () => Promise<AsyncIterator<String>>;
  activityLog: <
    T = Promise<AsyncIterator<ActivityLogItemSubscription>>
  >(args?: {
    where?: ActivityLogItemWhereInput;
    orderBy?: ActivityLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLog: <
    T = Promise<AsyncIterator<MembershipLogItemSubscription>>
  >(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLogContributions: <
    T = Promise<AsyncIterator<MembershipLogItemSubscription>>
  >(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsCreated: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsRSVPd: <T = Promise<AsyncIterator<RSVPSubscription>>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsHosted: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  trailsVisited: <T = Promise<AsyncIterator<TrailSubscription>>>(args?: {
    where?: TrailWhereInput;
    orderBy?: TrailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bandaids: <T = Promise<AsyncIterator<BandaidSubscription>>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReportsLogged: <T = Promise<AsyncIterator<RunReportSubscription>>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  joined: () => Promise<DateTimeOutput>;
  lastLogin: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  birthdate: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  contactInfo: <T = ContactInfoPromise>() => T;
  preferences: <T = PreferencePromise>() => T;
  userMeta: <T = UserMetaPromise>() => T;
  avatar: <T = CloudinaryImagePromise>() => T;
  isCharterMember: () => Promise<Boolean>;
  rig: <T = RigImagePromise>() => T;
  vehicle: <T = VehiclePromise>() => T;
  title: () => Promise<Title>;
  role: () => Promise<Role>;
  accountStatus: () => Promise<AccountStatus>;
  accountType: () => Promise<AccountType>;
  office: () => Promise<Office>;
  candidateFor: <T = FragmentableArray<Ballot>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votesReceived: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votedFor: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comfortLevel: () => Promise<String>;
  activityLog: <T = FragmentableArray<ActivityLogItem>>(args?: {
    where?: ActivityLogItemWhereInput;
    orderBy?: ActivityLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLog: <T = FragmentableArray<MembershipLogItem>>(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membershipLogContributions: <
    T = FragmentableArray<MembershipLogItem>
  >(args?: {
    where?: MembershipLogItemWhereInput;
    orderBy?: MembershipLogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsCreated: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsRSVPd: <T = FragmentableArray<RSVP>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventsHosted: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  trailsVisited: <T = FragmentableArray<Trail>>(args?: {
    where?: TrailWhereInput;
    orderBy?: TrailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bandaids: <T = FragmentableArray<Bandaid>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReportsLogged: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ContactInfo {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  street?: String;
  city?: String;
  state?: String;
  zip?: String;
  phone: String;
}

export interface ContactInfoPromise extends Promise<ContactInfo>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface ContactInfoSubscription
  extends Promise<AsyncIterator<ContactInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface ContactInfoNullablePromise
  extends Promise<ContactInfo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface Preference {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  emergencyContactName?: String;
  emergencyContactPhone?: String;
  photoPermissions?: Boolean;
  showPhoneNumber?: Boolean;
}

export interface PreferencePromise extends Promise<Preference>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  emergencyContactName: () => Promise<String>;
  emergencyContactPhone: () => Promise<String>;
  photoPermissions: () => Promise<Boolean>;
  showPhoneNumber: () => Promise<Boolean>;
}

export interface PreferenceSubscription
  extends Promise<AsyncIterator<Preference>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  emergencyContactName: () => Promise<AsyncIterator<String>>;
  emergencyContactPhone: () => Promise<AsyncIterator<String>>;
  photoPermissions: () => Promise<AsyncIterator<Boolean>>;
  showPhoneNumber: () => Promise<AsyncIterator<Boolean>>;
}

export interface PreferenceNullablePromise
  extends Promise<Preference | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  emergencyContactName: () => Promise<String>;
  emergencyContactPhone: () => Promise<String>;
  photoPermissions: () => Promise<Boolean>;
  showPhoneNumber: () => Promise<Boolean>;
}

export interface UserMeta {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  emailVerified?: Boolean;
  firstLoginComplete?: Boolean;
  accountSetupComplete?: Boolean;
  oldSitemigrationComplete?: Boolean;
}

export interface UserMetaPromise extends Promise<UserMeta>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  emailVerified: () => Promise<Boolean>;
  firstLoginComplete: () => Promise<Boolean>;
  accountSetupComplete: () => Promise<Boolean>;
  oldSitemigrationComplete: () => Promise<Boolean>;
}

export interface UserMetaSubscription
  extends Promise<AsyncIterator<UserMeta>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  firstLoginComplete: () => Promise<AsyncIterator<Boolean>>;
  accountSetupComplete: () => Promise<AsyncIterator<Boolean>>;
  oldSitemigrationComplete: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserMetaNullablePromise
  extends Promise<UserMeta | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  emailVerified: () => Promise<Boolean>;
  firstLoginComplete: () => Promise<Boolean>;
  accountSetupComplete: () => Promise<Boolean>;
  oldSitemigrationComplete: () => Promise<Boolean>;
}

export interface CloudinaryImage {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId: String;
  url?: String;
  smallUrl?: String;
}

export interface CloudinaryImagePromise
  extends Promise<CloudinaryImage>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  smallUrl: () => Promise<String>;
}

export interface CloudinaryImageSubscription
  extends Promise<AsyncIterator<CloudinaryImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publicId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  smallUrl: () => Promise<AsyncIterator<String>>;
}

export interface CloudinaryImageNullablePromise
  extends Promise<CloudinaryImage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  smallUrl: () => Promise<String>;
}

export interface RigImage {
  id: ID_Output;
}

export interface RigImagePromise extends Promise<RigImage>, Fragmentable {
  id: () => Promise<ID_Output>;
  image: <T = CloudinaryImagePromise>() => T;
}

export interface RigImageSubscription
  extends Promise<AsyncIterator<RigImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: <T = CloudinaryImageSubscription>() => T;
}

export interface RigImageNullablePromise
  extends Promise<RigImage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: <T = CloudinaryImagePromise>() => T;
}

export interface Vehicle {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  make: String;
  model: String;
  name?: String;
  trim?: String;
  outfitLevel?: OutfitLevel;
  mods: String[];
}

export interface VehiclePromise extends Promise<Vehicle>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  make: () => Promise<String>;
  model: () => Promise<String>;
  name: () => Promise<String>;
  trim: () => Promise<String>;
  image: <T = CloudinaryImagePromise>() => T;
  outfitLevel: () => Promise<OutfitLevel>;
  mods: () => Promise<String[]>;
}

export interface VehicleSubscription
  extends Promise<AsyncIterator<Vehicle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  make: () => Promise<AsyncIterator<String>>;
  model: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trim: () => Promise<AsyncIterator<String>>;
  image: <T = CloudinaryImageSubscription>() => T;
  outfitLevel: () => Promise<AsyncIterator<OutfitLevel>>;
  mods: () => Promise<AsyncIterator<String[]>>;
}

export interface VehicleNullablePromise
  extends Promise<Vehicle | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  make: () => Promise<String>;
  model: () => Promise<String>;
  name: () => Promise<String>;
  trim: () => Promise<String>;
  image: <T = CloudinaryImagePromise>() => T;
  outfitLevel: () => Promise<OutfitLevel>;
  mods: () => Promise<String[]>;
}

export interface Ballot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  desc?: String;
}

export interface BallotPromise extends Promise<Ballot>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  desc: () => Promise<String>;
  candidates: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BallotSubscription
  extends Promise<AsyncIterator<Ballot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  candidates: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BallotNullablePromise
  extends Promise<Ballot | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  desc: () => Promise<String>;
  candidates: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Vote {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VotePromise extends Promise<Vote>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  ballot: <T = BallotPromise>() => T;
  candidate: <T = UserPromise>() => T;
  voter: <T = UserPromise>() => T;
}

export interface VoteSubscription
  extends Promise<AsyncIterator<Vote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  ballot: <T = BallotSubscription>() => T;
  candidate: <T = UserSubscription>() => T;
  voter: <T = UserSubscription>() => T;
}

export interface VoteNullablePromise
  extends Promise<Vote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  ballot: <T = BallotPromise>() => T;
  candidate: <T = UserPromise>() => T;
  voter: <T = UserPromise>() => T;
}

export interface MembershipLogItem {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
  message: String;
  messageCode: MembershipMessageCode;
}

export interface MembershipLogItemPromise
  extends Promise<MembershipLogItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<MembershipMessageCode>;
  user: <T = UserPromise>() => T;
  logger: <T = UserPromise>() => T;
}

export interface MembershipLogItemSubscription
  extends Promise<AsyncIterator<MembershipLogItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  messageCode: () => Promise<AsyncIterator<MembershipMessageCode>>;
  user: <T = UserSubscription>() => T;
  logger: <T = UserSubscription>() => T;
}

export interface MembershipLogItemNullablePromise
  extends Promise<MembershipLogItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<MembershipMessageCode>;
  user: <T = UserPromise>() => T;
  logger: <T = UserPromise>() => T;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: EventType;
  title: String;
  description?: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  address?: String;
  trailDifficulty?: TrailDifficulty;
  trailNotes?: String;
  rallyAddress?: String;
  rallyTime?: DateTimeOutput;
  membersOnly?: Boolean;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<EventType>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  description: () => Promise<String>;
  featuredImage: <T = CloudinaryImagePromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  host: <T = UserPromise>() => T;
  rsvps: <T = FragmentableArray<RSVP>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<String>;
  trailDifficulty: () => Promise<TrailDifficulty>;
  trailNotes: () => Promise<String>;
  rallyAddress: () => Promise<String>;
  rallyTime: () => Promise<DateTimeOutput>;
  trail: <T = TrailPromise>() => T;
  bandaids: <T = FragmentableArray<Bandaid>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membersOnly: () => Promise<Boolean>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<EventType>>;
  title: () => Promise<AsyncIterator<String>>;
  creator: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  featuredImage: <T = CloudinaryImageSubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  host: <T = UserSubscription>() => T;
  rsvps: <T = Promise<AsyncIterator<RSVPSubscription>>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<AsyncIterator<String>>;
  trailDifficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  trailNotes: () => Promise<AsyncIterator<String>>;
  rallyAddress: () => Promise<AsyncIterator<String>>;
  rallyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  trail: <T = TrailSubscription>() => T;
  bandaids: <T = Promise<AsyncIterator<BandaidSubscription>>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = Promise<AsyncIterator<RunReportSubscription>>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membersOnly: () => Promise<AsyncIterator<Boolean>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<EventType>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  description: () => Promise<String>;
  featuredImage: <T = CloudinaryImagePromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  host: <T = UserPromise>() => T;
  rsvps: <T = FragmentableArray<RSVP>>(args?: {
    where?: RSVPWhereInput;
    orderBy?: RSVPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<String>;
  trailDifficulty: () => Promise<TrailDifficulty>;
  trailNotes: () => Promise<String>;
  rallyAddress: () => Promise<String>;
  rallyTime: () => Promise<DateTimeOutput>;
  trail: <T = TrailPromise>() => T;
  bandaids: <T = FragmentableArray<Bandaid>>(args?: {
    where?: BandaidWhereInput;
    orderBy?: BandaidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  membersOnly: () => Promise<Boolean>;
}

export interface RSVP {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: RSVPStatus;
}

export interface RSVPPromise extends Promise<RSVP>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  member: <T = UserPromise>() => T;
  event: <T = EventPromise>() => T;
  status: () => Promise<RSVPStatus>;
}

export interface RSVPSubscription
  extends Promise<AsyncIterator<RSVP>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  member: <T = UserSubscription>() => T;
  event: <T = EventSubscription>() => T;
  status: () => Promise<AsyncIterator<RSVPStatus>>;
}

export interface RSVPNullablePromise
  extends Promise<RSVP | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  member: <T = UserPromise>() => T;
  event: <T = EventPromise>() => T;
  status: () => Promise<RSVPStatus>;
}

export interface Trail {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  name?: String;
  description?: String;
  trailheadCoords?: String;
  address?: String;
  avgDifficulty?: TrailDifficulty;
  avgRatings?: Float;
  currentConditions?: String;
  conditionsLastReported?: DateTimeOutput;
  favoriteCount?: Int;
}

export interface TrailPromise extends Promise<Trail>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  featuredImage: <T = CloudinaryImagePromise>() => T;
  trailheadCoords: () => Promise<String>;
  address: () => Promise<String>;
  avgDifficulty: () => Promise<TrailDifficulty>;
  avgRatings: () => Promise<Float>;
  currentConditions: () => Promise<String>;
  conditionsLastReported: () => Promise<DateTimeOutput>;
  favoriteCount: () => Promise<Int>;
  pastEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  visitors: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrailSubscription
  extends Promise<AsyncIterator<Trail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  featuredImage: <T = CloudinaryImageSubscription>() => T;
  trailheadCoords: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  avgDifficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  avgRatings: () => Promise<AsyncIterator<Float>>;
  currentConditions: () => Promise<AsyncIterator<String>>;
  conditionsLastReported: () => Promise<AsyncIterator<DateTimeOutput>>;
  favoriteCount: () => Promise<AsyncIterator<Int>>;
  pastEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  visitors: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = Promise<AsyncIterator<RunReportSubscription>>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrailNullablePromise
  extends Promise<Trail | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  featuredImage: <T = CloudinaryImagePromise>() => T;
  trailheadCoords: () => Promise<String>;
  address: () => Promise<String>;
  avgDifficulty: () => Promise<TrailDifficulty>;
  avgRatings: () => Promise<Float>;
  currentConditions: () => Promise<String>;
  conditionsLastReported: () => Promise<DateTimeOutput>;
  favoriteCount: () => Promise<Int>;
  pastEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  visitors: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  runReports: <T = FragmentableArray<RunReport>>(args?: {
    where?: RunReportWhereInput;
    orderBy?: RunReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RunReport {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reportFiled: DateTimeOutput;
  title: String;
  description?: String;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  favorite?: Boolean;
}

export interface RunReportPromise extends Promise<RunReport>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reportFiled: () => Promise<DateTimeOutput>;
  reporter: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  trail: <T = TrailPromise>() => T;
  event: <T = EventPromise>() => T;
  weather: () => Promise<String>;
  difficulty: () => Promise<TrailDifficulty>;
  rating: () => Promise<Float>;
  condition: <T = ConditionPromise>() => T;
  favorite: () => Promise<Boolean>;
}

export interface RunReportSubscription
  extends Promise<AsyncIterator<RunReport>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reportFiled: () => Promise<AsyncIterator<DateTimeOutput>>;
  reporter: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  trail: <T = TrailSubscription>() => T;
  event: <T = EventSubscription>() => T;
  weather: () => Promise<AsyncIterator<String>>;
  difficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  rating: () => Promise<AsyncIterator<Float>>;
  condition: <T = ConditionSubscription>() => T;
  favorite: () => Promise<AsyncIterator<Boolean>>;
}

export interface RunReportNullablePromise
  extends Promise<RunReport | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reportFiled: () => Promise<DateTimeOutput>;
  reporter: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  trail: <T = TrailPromise>() => T;
  event: <T = EventPromise>() => T;
  weather: () => Promise<String>;
  difficulty: () => Promise<TrailDifficulty>;
  rating: () => Promise<Float>;
  condition: <T = ConditionPromise>() => T;
  favorite: () => Promise<Boolean>;
}

export interface Condition {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: TrailCondition;
  notes?: String;
}

export interface ConditionPromise extends Promise<Condition>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  report: <T = RunReportPromise>() => T;
  status: () => Promise<TrailCondition>;
  notes: () => Promise<String>;
}

export interface ConditionSubscription
  extends Promise<AsyncIterator<Condition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  report: <T = RunReportSubscription>() => T;
  status: () => Promise<AsyncIterator<TrailCondition>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ConditionNullablePromise
  extends Promise<Condition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  report: <T = RunReportPromise>() => T;
  status: () => Promise<TrailCondition>;
  notes: () => Promise<String>;
}

export interface Bandaid {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
}

export interface BandaidPromise extends Promise<Bandaid>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
  memberInvolved: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BandaidSubscription
  extends Promise<AsyncIterator<Bandaid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: <T = EventSubscription>() => T;
  memberInvolved: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BandaidNullablePromise
  extends Promise<Bandaid | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
  memberInvolved: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ActivityLogItemConnection {
  pageInfo: PageInfo;
  edges: ActivityLogItemEdge[];
}

export interface ActivityLogItemConnectionPromise
  extends Promise<ActivityLogItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityLogItemEdge>>() => T;
  aggregate: <T = AggregateActivityLogItemPromise>() => T;
}

export interface ActivityLogItemConnectionSubscription
  extends Promise<AsyncIterator<ActivityLogItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityLogItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivityLogItemSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityLogItemEdge {
  node: ActivityLogItem;
  cursor: String;
}

export interface ActivityLogItemEdgePromise
  extends Promise<ActivityLogItemEdge>,
    Fragmentable {
  node: <T = ActivityLogItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityLogItemEdgeSubscription
  extends Promise<AsyncIterator<ActivityLogItemEdge>>,
    Fragmentable {
  node: <T = ActivityLogItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivityLogItem {
  count: Int;
}

export interface AggregateActivityLogItemPromise
  extends Promise<AggregateActivityLogItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityLogItemSubscription
  extends Promise<AsyncIterator<AggregateActivityLogItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BallotConnection {
  pageInfo: PageInfo;
  edges: BallotEdge[];
}

export interface BallotConnectionPromise
  extends Promise<BallotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BallotEdge>>() => T;
  aggregate: <T = AggregateBallotPromise>() => T;
}

export interface BallotConnectionSubscription
  extends Promise<AsyncIterator<BallotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BallotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBallotSubscription>() => T;
}

export interface BallotEdge {
  node: Ballot;
  cursor: String;
}

export interface BallotEdgePromise extends Promise<BallotEdge>, Fragmentable {
  node: <T = BallotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BallotEdgeSubscription
  extends Promise<AsyncIterator<BallotEdge>>,
    Fragmentable {
  node: <T = BallotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBallot {
  count: Int;
}

export interface AggregateBallotPromise
  extends Promise<AggregateBallot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBallotSubscription
  extends Promise<AsyncIterator<AggregateBallot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BandaidConnection {
  pageInfo: PageInfo;
  edges: BandaidEdge[];
}

export interface BandaidConnectionPromise
  extends Promise<BandaidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BandaidEdge>>() => T;
  aggregate: <T = AggregateBandaidPromise>() => T;
}

export interface BandaidConnectionSubscription
  extends Promise<AsyncIterator<BandaidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BandaidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBandaidSubscription>() => T;
}

export interface BandaidEdge {
  node: Bandaid;
  cursor: String;
}

export interface BandaidEdgePromise extends Promise<BandaidEdge>, Fragmentable {
  node: <T = BandaidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BandaidEdgeSubscription
  extends Promise<AsyncIterator<BandaidEdge>>,
    Fragmentable {
  node: <T = BandaidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBandaid {
  count: Int;
}

export interface AggregateBandaidPromise
  extends Promise<AggregateBandaid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBandaidSubscription
  extends Promise<AsyncIterator<AggregateBandaid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CloudinaryImageConnection {
  pageInfo: PageInfo;
  edges: CloudinaryImageEdge[];
}

export interface CloudinaryImageConnectionPromise
  extends Promise<CloudinaryImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CloudinaryImageEdge>>() => T;
  aggregate: <T = AggregateCloudinaryImagePromise>() => T;
}

export interface CloudinaryImageConnectionSubscription
  extends Promise<AsyncIterator<CloudinaryImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CloudinaryImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCloudinaryImageSubscription>() => T;
}

export interface CloudinaryImageEdge {
  node: CloudinaryImage;
  cursor: String;
}

export interface CloudinaryImageEdgePromise
  extends Promise<CloudinaryImageEdge>,
    Fragmentable {
  node: <T = CloudinaryImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CloudinaryImageEdgeSubscription
  extends Promise<AsyncIterator<CloudinaryImageEdge>>,
    Fragmentable {
  node: <T = CloudinaryImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCloudinaryImage {
  count: Int;
}

export interface AggregateCloudinaryImagePromise
  extends Promise<AggregateCloudinaryImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCloudinaryImageSubscription
  extends Promise<AsyncIterator<AggregateCloudinaryImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ConditionConnection {
  pageInfo: PageInfo;
  edges: ConditionEdge[];
}

export interface ConditionConnectionPromise
  extends Promise<ConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConditionEdge>>() => T;
  aggregate: <T = AggregateConditionPromise>() => T;
}

export interface ConditionConnectionSubscription
  extends Promise<AsyncIterator<ConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConditionSubscription>() => T;
}

export interface ConditionEdge {
  node: Condition;
  cursor: String;
}

export interface ConditionEdgePromise
  extends Promise<ConditionEdge>,
    Fragmentable {
  node: <T = ConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConditionEdgeSubscription
  extends Promise<AsyncIterator<ConditionEdge>>,
    Fragmentable {
  node: <T = ConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCondition {
  count: Int;
}

export interface AggregateConditionPromise
  extends Promise<AggregateCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConditionSubscription
  extends Promise<AsyncIterator<AggregateCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactInfoConnection {
  pageInfo: PageInfo;
  edges: ContactInfoEdge[];
}

export interface ContactInfoConnectionPromise
  extends Promise<ContactInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactInfoEdge>>() => T;
  aggregate: <T = AggregateContactInfoPromise>() => T;
}

export interface ContactInfoConnectionSubscription
  extends Promise<AsyncIterator<ContactInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactInfoSubscription>() => T;
}

export interface ContactInfoEdge {
  node: ContactInfo;
  cursor: String;
}

export interface ContactInfoEdgePromise
  extends Promise<ContactInfoEdge>,
    Fragmentable {
  node: <T = ContactInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactInfoEdgeSubscription
  extends Promise<AsyncIterator<ContactInfoEdge>>,
    Fragmentable {
  node: <T = ContactInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactInfo {
  count: Int;
}

export interface AggregateContactInfoPromise
  extends Promise<AggregateContactInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactInfoSubscription
  extends Promise<AsyncIterator<AggregateContactInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Election {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  electionName: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
}

export interface ElectionPromise extends Promise<Election>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  electionName: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  races: <T = FragmentableArray<Ballot>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ElectionSubscription
  extends Promise<AsyncIterator<Election>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  electionName: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  races: <T = Promise<AsyncIterator<BallotSubscription>>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ElectionNullablePromise
  extends Promise<Election | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  electionName: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  races: <T = FragmentableArray<Ballot>>(args?: {
    where?: BallotWhereInput;
    orderBy?: BallotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ElectionConnection {
  pageInfo: PageInfo;
  edges: ElectionEdge[];
}

export interface ElectionConnectionPromise
  extends Promise<ElectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ElectionEdge>>() => T;
  aggregate: <T = AggregateElectionPromise>() => T;
}

export interface ElectionConnectionSubscription
  extends Promise<AsyncIterator<ElectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ElectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateElectionSubscription>() => T;
}

export interface ElectionEdge {
  node: Election;
  cursor: String;
}

export interface ElectionEdgePromise
  extends Promise<ElectionEdge>,
    Fragmentable {
  node: <T = ElectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ElectionEdgeSubscription
  extends Promise<AsyncIterator<ElectionEdge>>,
    Fragmentable {
  node: <T = ElectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateElection {
  count: Int;
}

export interface AggregateElectionPromise
  extends Promise<AggregateElection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateElectionSubscription
  extends Promise<AsyncIterator<AggregateElection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipLogItemConnection {
  pageInfo: PageInfo;
  edges: MembershipLogItemEdge[];
}

export interface MembershipLogItemConnectionPromise
  extends Promise<MembershipLogItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MembershipLogItemEdge>>() => T;
  aggregate: <T = AggregateMembershipLogItemPromise>() => T;
}

export interface MembershipLogItemConnectionSubscription
  extends Promise<AsyncIterator<MembershipLogItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MembershipLogItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMembershipLogItemSubscription>() => T;
}

export interface MembershipLogItemEdge {
  node: MembershipLogItem;
  cursor: String;
}

export interface MembershipLogItemEdgePromise
  extends Promise<MembershipLogItemEdge>,
    Fragmentable {
  node: <T = MembershipLogItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MembershipLogItemEdgeSubscription
  extends Promise<AsyncIterator<MembershipLogItemEdge>>,
    Fragmentable {
  node: <T = MembershipLogItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMembershipLogItem {
  count: Int;
}

export interface AggregateMembershipLogItemPromise
  extends Promise<AggregateMembershipLogItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMembershipLogItemSubscription
  extends Promise<AsyncIterator<AggregateMembershipLogItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PreferenceConnection {
  pageInfo: PageInfo;
  edges: PreferenceEdge[];
}

export interface PreferenceConnectionPromise
  extends Promise<PreferenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreferenceEdge>>() => T;
  aggregate: <T = AggregatePreferencePromise>() => T;
}

export interface PreferenceConnectionSubscription
  extends Promise<AsyncIterator<PreferenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreferenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreferenceSubscription>() => T;
}

export interface PreferenceEdge {
  node: Preference;
  cursor: String;
}

export interface PreferenceEdgePromise
  extends Promise<PreferenceEdge>,
    Fragmentable {
  node: <T = PreferencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreferenceEdgeSubscription
  extends Promise<AsyncIterator<PreferenceEdge>>,
    Fragmentable {
  node: <T = PreferenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePreference {
  count: Int;
}

export interface AggregatePreferencePromise
  extends Promise<AggregatePreference>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreferenceSubscription
  extends Promise<AsyncIterator<AggregatePreference>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RSVPConnection {
  pageInfo: PageInfo;
  edges: RSVPEdge[];
}

export interface RSVPConnectionPromise
  extends Promise<RSVPConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RSVPEdge>>() => T;
  aggregate: <T = AggregateRSVPPromise>() => T;
}

export interface RSVPConnectionSubscription
  extends Promise<AsyncIterator<RSVPConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RSVPEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRSVPSubscription>() => T;
}

export interface RSVPEdge {
  node: RSVP;
  cursor: String;
}

export interface RSVPEdgePromise extends Promise<RSVPEdge>, Fragmentable {
  node: <T = RSVPPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RSVPEdgeSubscription
  extends Promise<AsyncIterator<RSVPEdge>>,
    Fragmentable {
  node: <T = RSVPSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRSVP {
  count: Int;
}

export interface AggregateRSVPPromise
  extends Promise<AggregateRSVP>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRSVPSubscription
  extends Promise<AsyncIterator<AggregateRSVP>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Registration {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
  email: String;
  source: String;
  token: String;
  tokenExpiry: Float;
}

export interface RegistrationPromise
  extends Promise<Registration>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  source: () => Promise<String>;
  token: () => Promise<String>;
  tokenExpiry: () => Promise<Float>;
}

export interface RegistrationSubscription
  extends Promise<AsyncIterator<Registration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  tokenExpiry: () => Promise<AsyncIterator<Float>>;
}

export interface RegistrationNullablePromise
  extends Promise<Registration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  source: () => Promise<String>;
  token: () => Promise<String>;
  tokenExpiry: () => Promise<Float>;
}

export interface RegistrationConnection {
  pageInfo: PageInfo;
  edges: RegistrationEdge[];
}

export interface RegistrationConnectionPromise
  extends Promise<RegistrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegistrationEdge>>() => T;
  aggregate: <T = AggregateRegistrationPromise>() => T;
}

export interface RegistrationConnectionSubscription
  extends Promise<AsyncIterator<RegistrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegistrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegistrationSubscription>() => T;
}

export interface RegistrationEdge {
  node: Registration;
  cursor: String;
}

export interface RegistrationEdgePromise
  extends Promise<RegistrationEdge>,
    Fragmentable {
  node: <T = RegistrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegistrationEdgeSubscription
  extends Promise<AsyncIterator<RegistrationEdge>>,
    Fragmentable {
  node: <T = RegistrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegistration {
  count: Int;
}

export interface AggregateRegistrationPromise
  extends Promise<AggregateRegistration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegistrationSubscription
  extends Promise<AsyncIterator<AggregateRegistration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RigImageConnection {
  pageInfo: PageInfo;
  edges: RigImageEdge[];
}

export interface RigImageConnectionPromise
  extends Promise<RigImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RigImageEdge>>() => T;
  aggregate: <T = AggregateRigImagePromise>() => T;
}

export interface RigImageConnectionSubscription
  extends Promise<AsyncIterator<RigImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RigImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRigImageSubscription>() => T;
}

export interface RigImageEdge {
  node: RigImage;
  cursor: String;
}

export interface RigImageEdgePromise
  extends Promise<RigImageEdge>,
    Fragmentable {
  node: <T = RigImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RigImageEdgeSubscription
  extends Promise<AsyncIterator<RigImageEdge>>,
    Fragmentable {
  node: <T = RigImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRigImage {
  count: Int;
}

export interface AggregateRigImagePromise
  extends Promise<AggregateRigImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRigImageSubscription
  extends Promise<AsyncIterator<AggregateRigImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RunReportConnection {
  pageInfo: PageInfo;
  edges: RunReportEdge[];
}

export interface RunReportConnectionPromise
  extends Promise<RunReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RunReportEdge>>() => T;
  aggregate: <T = AggregateRunReportPromise>() => T;
}

export interface RunReportConnectionSubscription
  extends Promise<AsyncIterator<RunReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RunReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRunReportSubscription>() => T;
}

export interface RunReportEdge {
  node: RunReport;
  cursor: String;
}

export interface RunReportEdgePromise
  extends Promise<RunReportEdge>,
    Fragmentable {
  node: <T = RunReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RunReportEdgeSubscription
  extends Promise<AsyncIterator<RunReportEdge>>,
    Fragmentable {
  node: <T = RunReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRunReport {
  count: Int;
}

export interface AggregateRunReportPromise
  extends Promise<AggregateRunReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRunReportSubscription
  extends Promise<AsyncIterator<AggregateRunReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrailConnection {
  pageInfo: PageInfo;
  edges: TrailEdge[];
}

export interface TrailConnectionPromise
  extends Promise<TrailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrailEdge>>() => T;
  aggregate: <T = AggregateTrailPromise>() => T;
}

export interface TrailConnectionSubscription
  extends Promise<AsyncIterator<TrailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrailSubscription>() => T;
}

export interface TrailEdge {
  node: Trail;
  cursor: String;
}

export interface TrailEdgePromise extends Promise<TrailEdge>, Fragmentable {
  node: <T = TrailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrailEdgeSubscription
  extends Promise<AsyncIterator<TrailEdge>>,
    Fragmentable {
  node: <T = TrailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTrail {
  count: Int;
}

export interface AggregateTrailPromise
  extends Promise<AggregateTrail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrailSubscription
  extends Promise<AsyncIterator<AggregateTrail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserMetaConnection {
  pageInfo: PageInfo;
  edges: UserMetaEdge[];
}

export interface UserMetaConnectionPromise
  extends Promise<UserMetaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserMetaEdge>>() => T;
  aggregate: <T = AggregateUserMetaPromise>() => T;
}

export interface UserMetaConnectionSubscription
  extends Promise<AsyncIterator<UserMetaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserMetaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserMetaSubscription>() => T;
}

export interface UserMetaEdge {
  node: UserMeta;
  cursor: String;
}

export interface UserMetaEdgePromise
  extends Promise<UserMetaEdge>,
    Fragmentable {
  node: <T = UserMetaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserMetaEdgeSubscription
  extends Promise<AsyncIterator<UserMetaEdge>>,
    Fragmentable {
  node: <T = UserMetaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserMeta {
  count: Int;
}

export interface AggregateUserMetaPromise
  extends Promise<AggregateUserMeta>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserMetaSubscription
  extends Promise<AsyncIterator<AggregateUserMeta>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VehicleConnection {
  pageInfo: PageInfo;
  edges: VehicleEdge[];
}

export interface VehicleConnectionPromise
  extends Promise<VehicleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VehicleEdge>>() => T;
  aggregate: <T = AggregateVehiclePromise>() => T;
}

export interface VehicleConnectionSubscription
  extends Promise<AsyncIterator<VehicleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VehicleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVehicleSubscription>() => T;
}

export interface VehicleEdge {
  node: Vehicle;
  cursor: String;
}

export interface VehicleEdgePromise extends Promise<VehicleEdge>, Fragmentable {
  node: <T = VehiclePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VehicleEdgeSubscription
  extends Promise<AsyncIterator<VehicleEdge>>,
    Fragmentable {
  node: <T = VehicleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVehicle {
  count: Int;
}

export interface AggregateVehiclePromise
  extends Promise<AggregateVehicle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVehicleSubscription
  extends Promise<AsyncIterator<AggregateVehicle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VoteConnection {
  pageInfo: PageInfo;
  edges: VoteEdge[];
}

export interface VoteConnectionPromise
  extends Promise<VoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoteEdge>>() => T;
  aggregate: <T = AggregateVotePromise>() => T;
}

export interface VoteConnectionSubscription
  extends Promise<AsyncIterator<VoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoteSubscription>() => T;
}

export interface VoteEdge {
  node: Vote;
  cursor: String;
}

export interface VoteEdgePromise extends Promise<VoteEdge>, Fragmentable {
  node: <T = VotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoteEdgeSubscription
  extends Promise<AsyncIterator<VoteEdge>>,
    Fragmentable {
  node: <T = VoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVote {
  count: Int;
}

export interface AggregateVotePromise
  extends Promise<AggregateVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoteSubscription
  extends Promise<AsyncIterator<AggregateVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivityLogItemSubscriptionPayload {
  mutation: MutationType;
  node: ActivityLogItem;
  updatedFields: String[];
  previousValues: ActivityLogItemPreviousValues;
}

export interface ActivityLogItemSubscriptionPayloadPromise
  extends Promise<ActivityLogItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityLogItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityLogItemPreviousValuesPromise>() => T;
}

export interface ActivityLogItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityLogItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityLogItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityLogItemPreviousValuesSubscription>() => T;
}

export interface ActivityLogItemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
  message: String;
  messageCode: ActivityMessageCode;
  link?: String;
}

export interface ActivityLogItemPreviousValuesPromise
  extends Promise<ActivityLogItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<ActivityMessageCode>;
  link: () => Promise<String>;
}

export interface ActivityLogItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityLogItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  messageCode: () => Promise<AsyncIterator<ActivityMessageCode>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface BallotSubscriptionPayload {
  mutation: MutationType;
  node: Ballot;
  updatedFields: String[];
  previousValues: BallotPreviousValues;
}

export interface BallotSubscriptionPayloadPromise
  extends Promise<BallotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BallotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BallotPreviousValuesPromise>() => T;
}

export interface BallotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BallotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BallotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BallotPreviousValuesSubscription>() => T;
}

export interface BallotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  desc?: String;
}

export interface BallotPreviousValuesPromise
  extends Promise<BallotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface BallotPreviousValuesSubscription
  extends Promise<AsyncIterator<BallotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface BandaidSubscriptionPayload {
  mutation: MutationType;
  node: Bandaid;
  updatedFields: String[];
  previousValues: BandaidPreviousValues;
}

export interface BandaidSubscriptionPayloadPromise
  extends Promise<BandaidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BandaidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BandaidPreviousValuesPromise>() => T;
}

export interface BandaidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BandaidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BandaidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BandaidPreviousValuesSubscription>() => T;
}

export interface BandaidPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
}

export interface BandaidPreviousValuesPromise
  extends Promise<BandaidPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BandaidPreviousValuesSubscription
  extends Promise<AsyncIterator<BandaidPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface CloudinaryImageSubscriptionPayload {
  mutation: MutationType;
  node: CloudinaryImage;
  updatedFields: String[];
  previousValues: CloudinaryImagePreviousValues;
}

export interface CloudinaryImageSubscriptionPayloadPromise
  extends Promise<CloudinaryImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CloudinaryImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CloudinaryImagePreviousValuesPromise>() => T;
}

export interface CloudinaryImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CloudinaryImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CloudinaryImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CloudinaryImagePreviousValuesSubscription>() => T;
}

export interface CloudinaryImagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId: String;
  url?: String;
  smallUrl?: String;
}

export interface CloudinaryImagePreviousValuesPromise
  extends Promise<CloudinaryImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  smallUrl: () => Promise<String>;
}

export interface CloudinaryImagePreviousValuesSubscription
  extends Promise<AsyncIterator<CloudinaryImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publicId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  smallUrl: () => Promise<AsyncIterator<String>>;
}

export interface ConditionSubscriptionPayload {
  mutation: MutationType;
  node: Condition;
  updatedFields: String[];
  previousValues: ConditionPreviousValues;
}

export interface ConditionSubscriptionPayloadPromise
  extends Promise<ConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConditionPreviousValuesPromise>() => T;
}

export interface ConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConditionPreviousValuesSubscription>() => T;
}

export interface ConditionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: TrailCondition;
  notes?: String;
}

export interface ConditionPreviousValuesPromise
  extends Promise<ConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<TrailCondition>;
  notes: () => Promise<String>;
}

export interface ConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<ConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<TrailCondition>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ContactInfoSubscriptionPayload {
  mutation: MutationType;
  node: ContactInfo;
  updatedFields: String[];
  previousValues: ContactInfoPreviousValues;
}

export interface ContactInfoSubscriptionPayloadPromise
  extends Promise<ContactInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactInfoPreviousValuesPromise>() => T;
}

export interface ContactInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactInfoPreviousValuesSubscription>() => T;
}

export interface ContactInfoPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  street?: String;
  city?: String;
  state?: String;
  zip?: String;
  phone: String;
}

export interface ContactInfoPreviousValuesPromise
  extends Promise<ContactInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface ContactInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface ElectionSubscriptionPayload {
  mutation: MutationType;
  node: Election;
  updatedFields: String[];
  previousValues: ElectionPreviousValues;
}

export interface ElectionSubscriptionPayloadPromise
  extends Promise<ElectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ElectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ElectionPreviousValuesPromise>() => T;
}

export interface ElectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ElectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ElectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ElectionPreviousValuesSubscription>() => T;
}

export interface ElectionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  electionName: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
}

export interface ElectionPreviousValuesPromise
  extends Promise<ElectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  electionName: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
}

export interface ElectionPreviousValuesSubscription
  extends Promise<AsyncIterator<ElectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  electionName: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: EventType;
  title: String;
  description?: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  address?: String;
  trailDifficulty?: TrailDifficulty;
  trailNotes?: String;
  rallyAddress?: String;
  rallyTime?: DateTimeOutput;
  membersOnly?: Boolean;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<EventType>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  address: () => Promise<String>;
  trailDifficulty: () => Promise<TrailDifficulty>;
  trailNotes: () => Promise<String>;
  rallyAddress: () => Promise<String>;
  rallyTime: () => Promise<DateTimeOutput>;
  membersOnly: () => Promise<Boolean>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<EventType>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  address: () => Promise<AsyncIterator<String>>;
  trailDifficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  trailNotes: () => Promise<AsyncIterator<String>>;
  rallyAddress: () => Promise<AsyncIterator<String>>;
  rallyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  membersOnly: () => Promise<AsyncIterator<Boolean>>;
}

export interface MembershipLogItemSubscriptionPayload {
  mutation: MutationType;
  node: MembershipLogItem;
  updatedFields: String[];
  previousValues: MembershipLogItemPreviousValues;
}

export interface MembershipLogItemSubscriptionPayloadPromise
  extends Promise<MembershipLogItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MembershipLogItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MembershipLogItemPreviousValuesPromise>() => T;
}

export interface MembershipLogItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MembershipLogItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MembershipLogItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MembershipLogItemPreviousValuesSubscription>() => T;
}

export interface MembershipLogItemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
  message: String;
  messageCode: MembershipMessageCode;
}

export interface MembershipLogItemPreviousValuesPromise
  extends Promise<MembershipLogItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  messageCode: () => Promise<MembershipMessageCode>;
}

export interface MembershipLogItemPreviousValuesSubscription
  extends Promise<AsyncIterator<MembershipLogItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  messageCode: () => Promise<AsyncIterator<MembershipMessageCode>>;
}

export interface PreferenceSubscriptionPayload {
  mutation: MutationType;
  node: Preference;
  updatedFields: String[];
  previousValues: PreferencePreviousValues;
}

export interface PreferenceSubscriptionPayloadPromise
  extends Promise<PreferenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreferencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreferencePreviousValuesPromise>() => T;
}

export interface PreferenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreferenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreferenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreferencePreviousValuesSubscription>() => T;
}

export interface PreferencePreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  emergencyContactName?: String;
  emergencyContactPhone?: String;
  photoPermissions?: Boolean;
  showPhoneNumber?: Boolean;
}

export interface PreferencePreviousValuesPromise
  extends Promise<PreferencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  emergencyContactName: () => Promise<String>;
  emergencyContactPhone: () => Promise<String>;
  photoPermissions: () => Promise<Boolean>;
  showPhoneNumber: () => Promise<Boolean>;
}

export interface PreferencePreviousValuesSubscription
  extends Promise<AsyncIterator<PreferencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  emergencyContactName: () => Promise<AsyncIterator<String>>;
  emergencyContactPhone: () => Promise<AsyncIterator<String>>;
  photoPermissions: () => Promise<AsyncIterator<Boolean>>;
  showPhoneNumber: () => Promise<AsyncIterator<Boolean>>;
}

export interface RSVPSubscriptionPayload {
  mutation: MutationType;
  node: RSVP;
  updatedFields: String[];
  previousValues: RSVPPreviousValues;
}

export interface RSVPSubscriptionPayloadPromise
  extends Promise<RSVPSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RSVPPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RSVPPreviousValuesPromise>() => T;
}

export interface RSVPSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RSVPSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RSVPSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RSVPPreviousValuesSubscription>() => T;
}

export interface RSVPPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: RSVPStatus;
}

export interface RSVPPreviousValuesPromise
  extends Promise<RSVPPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<RSVPStatus>;
}

export interface RSVPPreviousValuesSubscription
  extends Promise<AsyncIterator<RSVPPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<RSVPStatus>>;
}

export interface RegistrationSubscriptionPayload {
  mutation: MutationType;
  node: Registration;
  updatedFields: String[];
  previousValues: RegistrationPreviousValues;
}

export interface RegistrationSubscriptionPayloadPromise
  extends Promise<RegistrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegistrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegistrationPreviousValuesPromise>() => T;
}

export interface RegistrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegistrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegistrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegistrationPreviousValuesSubscription>() => T;
}

export interface RegistrationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName?: String;
  lastName?: String;
  email: String;
  source: String;
  token: String;
  tokenExpiry: Float;
}

export interface RegistrationPreviousValuesPromise
  extends Promise<RegistrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  source: () => Promise<String>;
  token: () => Promise<String>;
  tokenExpiry: () => Promise<Float>;
}

export interface RegistrationPreviousValuesSubscription
  extends Promise<AsyncIterator<RegistrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  tokenExpiry: () => Promise<AsyncIterator<Float>>;
}

export interface RigImageSubscriptionPayload {
  mutation: MutationType;
  node: RigImage;
  updatedFields: String[];
  previousValues: RigImagePreviousValues;
}

export interface RigImageSubscriptionPayloadPromise
  extends Promise<RigImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RigImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RigImagePreviousValuesPromise>() => T;
}

export interface RigImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RigImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RigImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RigImagePreviousValuesSubscription>() => T;
}

export interface RigImagePreviousValues {
  id: ID_Output;
}

export interface RigImagePreviousValuesPromise
  extends Promise<RigImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface RigImagePreviousValuesSubscription
  extends Promise<AsyncIterator<RigImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface RunReportSubscriptionPayload {
  mutation: MutationType;
  node: RunReport;
  updatedFields: String[];
  previousValues: RunReportPreviousValues;
}

export interface RunReportSubscriptionPayloadPromise
  extends Promise<RunReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RunReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RunReportPreviousValuesPromise>() => T;
}

export interface RunReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RunReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RunReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RunReportPreviousValuesSubscription>() => T;
}

export interface RunReportPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reportFiled: DateTimeOutput;
  title: String;
  description?: String;
  weather: String;
  difficulty: TrailDifficulty;
  rating: Float;
  favorite?: Boolean;
}

export interface RunReportPreviousValuesPromise
  extends Promise<RunReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reportFiled: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  weather: () => Promise<String>;
  difficulty: () => Promise<TrailDifficulty>;
  rating: () => Promise<Float>;
  favorite: () => Promise<Boolean>;
}

export interface RunReportPreviousValuesSubscription
  extends Promise<AsyncIterator<RunReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reportFiled: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  weather: () => Promise<AsyncIterator<String>>;
  difficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  rating: () => Promise<AsyncIterator<Float>>;
  favorite: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrailSubscriptionPayload {
  mutation: MutationType;
  node: Trail;
  updatedFields: String[];
  previousValues: TrailPreviousValues;
}

export interface TrailSubscriptionPayloadPromise
  extends Promise<TrailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrailPreviousValuesPromise>() => T;
}

export interface TrailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrailPreviousValuesSubscription>() => T;
}

export interface TrailPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  name?: String;
  description?: String;
  trailheadCoords?: String;
  address?: String;
  avgDifficulty?: TrailDifficulty;
  avgRatings?: Float;
  currentConditions?: String;
  conditionsLastReported?: DateTimeOutput;
  favoriteCount?: Int;
}

export interface TrailPreviousValuesPromise
  extends Promise<TrailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  trailheadCoords: () => Promise<String>;
  address: () => Promise<String>;
  avgDifficulty: () => Promise<TrailDifficulty>;
  avgRatings: () => Promise<Float>;
  currentConditions: () => Promise<String>;
  conditionsLastReported: () => Promise<DateTimeOutput>;
  favoriteCount: () => Promise<Int>;
}

export interface TrailPreviousValuesSubscription
  extends Promise<AsyncIterator<TrailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  trailheadCoords: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  avgDifficulty: () => Promise<AsyncIterator<TrailDifficulty>>;
  avgRatings: () => Promise<AsyncIterator<Float>>;
  currentConditions: () => Promise<AsyncIterator<String>>;
  conditionsLastReported: () => Promise<AsyncIterator<DateTimeOutput>>;
  favoriteCount: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  joined?: DateTimeOutput;
  lastLogin?: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  gender?: Gender;
  birthdate?: DateTimeOutput;
  username: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  isCharterMember?: Boolean;
  title?: Title;
  role: Role;
  accountStatus: AccountStatus;
  accountType: AccountType;
  office?: Office;
  comfortLevel?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  joined: () => Promise<DateTimeOutput>;
  lastLogin: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  birthdate: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  isCharterMember: () => Promise<Boolean>;
  title: () => Promise<Title>;
  role: () => Promise<Role>;
  accountStatus: () => Promise<AccountStatus>;
  accountType: () => Promise<AccountType>;
  office: () => Promise<Office>;
  comfortLevel: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  joined: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  isCharterMember: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<Title>>;
  role: () => Promise<AsyncIterator<Role>>;
  accountStatus: () => Promise<AsyncIterator<AccountStatus>>;
  accountType: () => Promise<AsyncIterator<AccountType>>;
  office: () => Promise<AsyncIterator<Office>>;
  comfortLevel: () => Promise<AsyncIterator<String>>;
}

export interface UserMetaSubscriptionPayload {
  mutation: MutationType;
  node: UserMeta;
  updatedFields: String[];
  previousValues: UserMetaPreviousValues;
}

export interface UserMetaSubscriptionPayloadPromise
  extends Promise<UserMetaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserMetaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserMetaPreviousValuesPromise>() => T;
}

export interface UserMetaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserMetaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserMetaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserMetaPreviousValuesSubscription>() => T;
}

export interface UserMetaPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  emailVerified?: Boolean;
  firstLoginComplete?: Boolean;
  accountSetupComplete?: Boolean;
  oldSitemigrationComplete?: Boolean;
}

export interface UserMetaPreviousValuesPromise
  extends Promise<UserMetaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  emailVerified: () => Promise<Boolean>;
  firstLoginComplete: () => Promise<Boolean>;
  accountSetupComplete: () => Promise<Boolean>;
  oldSitemigrationComplete: () => Promise<Boolean>;
}

export interface UserMetaPreviousValuesSubscription
  extends Promise<AsyncIterator<UserMetaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  firstLoginComplete: () => Promise<AsyncIterator<Boolean>>;
  accountSetupComplete: () => Promise<AsyncIterator<Boolean>>;
  oldSitemigrationComplete: () => Promise<AsyncIterator<Boolean>>;
}

export interface VehicleSubscriptionPayload {
  mutation: MutationType;
  node: Vehicle;
  updatedFields: String[];
  previousValues: VehiclePreviousValues;
}

export interface VehicleSubscriptionPayloadPromise
  extends Promise<VehicleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VehiclePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VehiclePreviousValuesPromise>() => T;
}

export interface VehicleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VehicleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VehicleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VehiclePreviousValuesSubscription>() => T;
}

export interface VehiclePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  make: String;
  model: String;
  name?: String;
  trim?: String;
  outfitLevel?: OutfitLevel;
  mods: String[];
}

export interface VehiclePreviousValuesPromise
  extends Promise<VehiclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  make: () => Promise<String>;
  model: () => Promise<String>;
  name: () => Promise<String>;
  trim: () => Promise<String>;
  outfitLevel: () => Promise<OutfitLevel>;
  mods: () => Promise<String[]>;
}

export interface VehiclePreviousValuesSubscription
  extends Promise<AsyncIterator<VehiclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  make: () => Promise<AsyncIterator<String>>;
  model: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trim: () => Promise<AsyncIterator<String>>;
  outfitLevel: () => Promise<AsyncIterator<OutfitLevel>>;
  mods: () => Promise<AsyncIterator<String[]>>;
}

export interface VoteSubscriptionPayload {
  mutation: MutationType;
  node: Vote;
  updatedFields: String[];
  previousValues: VotePreviousValues;
}

export interface VoteSubscriptionPayloadPromise
  extends Promise<VoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotePreviousValuesPromise>() => T;
}

export interface VoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotePreviousValuesSubscription>() => T;
}

export interface VotePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VotePreviousValuesPromise
  extends Promise<VotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VotePreviousValuesSubscription
  extends Promise<AsyncIterator<VotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "AccountStatus",
    embedded: false
  },
  {
    name: "AccountType",
    embedded: false
  },
  {
    name: "Office",
    embedded: false
  },
  {
    name: "Title",
    embedded: false
  },
  {
    name: "Poll",
    embedded: false
  },
  {
    name: "TrailDifficulty",
    embedded: false
  },
  {
    name: "MigrationStatus",
    embedded: false
  },
  {
    name: "RSVPStatus",
    embedded: false
  },
  {
    name: "TrailCondition",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "OutfitLevel",
    embedded: false
  },
  {
    name: "ActivityMessageCode",
    embedded: false
  },
  {
    name: "MembershipMessageCode",
    embedded: false
  },
  {
    name: "EventType",
    embedded: false
  },
  {
    name: "Registration",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "ContactInfo",
    embedded: false
  },
  {
    name: "Preference",
    embedded: false
  },
  {
    name: "UserMeta",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "RSVP",
    embedded: false
  },
  {
    name: "Trail",
    embedded: false
  },
  {
    name: "RunReport",
    embedded: false
  },
  {
    name: "Condition",
    embedded: false
  },
  {
    name: "Bandaid",
    embedded: false
  },
  {
    name: "Election",
    embedded: false
  },
  {
    name: "Ballot",
    embedded: false
  },
  {
    name: "Vote",
    embedded: false
  },
  {
    name: "Vehicle",
    embedded: false
  },
  {
    name: "ActivityLogItem",
    embedded: false
  },
  {
    name: "MembershipLogItem",
    embedded: false
  },
  {
    name: "RigImage",
    embedded: false
  },
  {
    name: "CloudinaryImage",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
